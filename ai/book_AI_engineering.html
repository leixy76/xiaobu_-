<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>《AI工程》核心摘要 (动态交互版)</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
            line-height: 1.7;
            color: #333;
            background-color: #f9f9f9;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background-color: #fff;
            padding: 20px 40px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }
        h1 {
            text-align: center;
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        .intro {
            background-color: #eaf5ff;
            border-left: 5px solid #3498db;
            padding: 15px 20px;
            margin-bottom: 30px;
            border-radius: 5px;
        }
        details {
            background-color: #ffffff;
            border: 1px solid #ddd;
            border-radius: 8px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
            overflow: hidden;
        }
        details[open] {
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        summary {
            padding: 15px 20px;
            font-weight: bold;
            font-size: 1.2em;
            cursor: pointer;
            outline: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: #f7f7f7;
            color: #2c3e50;
            transition: background-color 0.2s ease;
        }
        summary:hover {
            background-color: #eef;
        }
        summary::after {
            content: '▼';
            font-size: 0.8em;
            transition: transform 0.3s ease;
        }
        details[open] summary::after {
            transform: rotate(180deg);
        }
        .content {
            padding: 0 20px 20px 40px;
            border-top: 1px solid #eee;
        }
        ul {
            padding-left: 20px;
        }
        li {
            margin-bottom: 10px;
        }
        .highlight {
            padding: 8px 12px;
            border-radius: 5px;
            margin: 5px 0;
            display: block;
        }
        .fact {
            background-color: #e8f4fd;
            border-left: 4px solid #3498db;
        }
        .opinion {
            background-color: #fff9e6;
            border-left: 4px solid #f1c40f;
        }
        code {
            background-color: #eee;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
            font-size: 0.9em;
        }
        strong {
            color: #2980b9;
        }
    /* 主容器布局调整 - 移除flex布局以保持原始排版 */

.attachments-panel {
    width: 250px;
    background: #fff;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    height: fit-content;
    position: sticky;
    top: 20px;
    flex-shrink: 0;
    z-index: 1000;
    border: 1px solid #e0e0e0;
}
.attachments-panel h3 {
    color: #004085;
    margin-top: 0;
    margin-bottom: 15px;
    text-align: center;
    border-bottom: 2px solid #004085;
    padding-bottom: 10px;
}
.attachment-item {
    background-color: #f8f9fa;
    border: 1px solid #ced4da;
    border-radius: 5px;
    padding: 15px;
    margin-bottom: 15px;
    transition: all 0.3s ease;
}
.attachment-item:hover {
    background-color: #e9ecef;
    border-color: #004085;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}
.attachment-item h4 {
    margin: 0 0 8px 0;
    color: #004085;
    font-size: 14px;
}
.attachment-item p {
    margin: 0 0 10px 0;
    font-size: 12px;
    color: #6c757d;
    line-height: 1.4;
}
.download-btn {
    display: inline-block;
    background-color: #28a745;
    color: white;
    text-decoration: none;
    padding: 8px 16px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: bold;
    transition: background-color 0.3s ease;
    width: 100%;
    text-align: center;
    box-sizing: border-box;
}
.download-btn:hover {
    background-color: #218838;
    text-decoration: none;
    color: white;
}
.download-btn:before {
    content: "▼ ";
    margin-right: 5px;
}

/* 可折叠浮动框样式 */
.attachments-panel {
    position: fixed;
    top: 10px;
    right: 10px;
    width: auto; /* 自适应宽度 */
    min-width: 250px; /* 最小宽度 */
    max-width: calc(100vw - 60px); /* 最大宽度，留出边距 */
    max-height: calc(100vh - 80px); /* 留出更多空间避免滚动条 */
    overflow-y: auto;
    overflow-x: hidden; /* 隐藏横向滚动条 */
    z-index: 9999;
    box-shadow: 0 8px 24px rgba(0,0,0,0.25);
    border: 2px solid #004085;
    transform: translateX(100%); /* 默认完全隐藏 */
    transition: transform 0.3s ease;
    /* 自定义滚动条样式 */
    scrollbar-width: thin;
    scrollbar-color: #004085 #f0f0f0;
}

/* WebKit浏览器滚动条样式 */
.attachments-panel::-webkit-scrollbar {
    width: 6px;
}

.attachments-panel::-webkit-scrollbar-track {
    background: #f0f0f0;
    border-radius: 3px;
}

.attachments-panel::-webkit-scrollbar-thumb {
    background: #004085;
    border-radius: 3px;
}

.attachments-panel::-webkit-scrollbar-thumb:hover {
    background: #0056b3;
}

/* 展开时显示 */
.attachments-panel.expanded {
    transform: translateX(0);
}

/* 移除container的margin-right设置，保持原始布局 */

.attachment-item {
    width: 250px;
    margin-right: 0;
    display: block;
    margin-bottom: 12px;
    white-space: nowrap; /* 防止文本换行导致宽度过大 */
}

.attachment-item h4 {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis; /* 长文本显示省略号 */
    max-width: 100%;
}

.attachments-panel h3 {
    font-size: 16px;
    margin-bottom: 12px;
    white-space: nowrap; /* 标题不换行 */
}

.attachments-panel a {
    white-space: nowrap; /* 链接文本不换行 */
    overflow: hidden;
    text-overflow: ellipsis;
    display: inline-block;
    max-width: 100%;
}

/* 浮动切换按钮 */
.float-toggle {
    position: fixed;
    top: 10px;
    right: 10px;
    width: 50px;
    height: 50px;
    background: #004085;
    color: white;
    border: none;
    border-radius: 50%;
    font-size: 20px;
    cursor: pointer;
    z-index: 10000;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

.float-toggle:hover {
    background: #0056b3;
    transform: scale(1.1);
}

.float-toggle:active {
    transform: scale(0.95);
}

/* 当面板展开时，按钮位置动态调整 */
.attachments-panel.expanded ~ .float-toggle {
    right: 20px; /* 保持在面板左侧的固定位置 */
    opacity: 0.7; /* 展开时降低透明度，避免遮挡 */
}
    </style>
</head>
<body>
    <div class="container">
        <h1>《AI工程：构建基于基础模型的应用》核心摘要</h1>
        <div class="intro">
            <p>本书是<strong>Chip Huyen</strong>继《设计机器学习系统》之后的又一力作，旨在为所有希望利用基础模型（Foundation Models）解决实际问题的人提供一个全面的端到端框架。它不仅仅关注工具或API，更聚焦于那些经得起时间考验的工程基础和最佳实践。</p>
        </div>

        <details>
            <summary>前言：本书精髓</summary>
            <div class="content">
                <ul>
                    <li><span class="highlight opinion">💡 <strong>核心观点：</strong> AI工程正在从一个专业学科转变为人人可用的开发工具。其爆发的核心驱动力是：<strong>1) AI能力通用化</strong>，解锁了海量新应用；<strong>2) 投资激增</strong>，企业纷纷布局；<strong>3) 入门门槛降低</strong>，模型即服务（MaaS）模式普及。</span></li>
                    <li><span class="highlight fact">📖 <strong>本书是什么：</strong> 一个关于如何适配（adapt）基础模型（包括LLMs和LMMs）来解决具体问题的<strong>系统性框架</strong>，而非特定工具的教程。它侧重于基本原理、权衡分析和问题解决思路。</span></li>
                    <li><span class="highlight fact">📖 <strong>本书不是什么：</strong> 它不是机器学习理论书，也不是代码教程。它假设读者具备基本的ML概念知识（如概率、梯度下降等），但会为不熟悉的读者提供指引。</span></li>
                    <li><span class="highlight opinion">💡 <strong>适用人群：</strong> AI/ML工程师、数据科学家、工程经理、技术产品经理，以及任何想要系统化构建、评估和优化AI应用的人。</span></li>
                </ul>
            </div>
        </details>

        <details>
            <summary>第一章：AI应用构建入门</summary>
            <div class="content">
                <ul>
                    <li><span class="highlight fact">📖 <strong>核心演进路径：</strong> 语言模型 →（得益于<strong>自监督学习</strong>和<strong>规模化</strong>）→ 大语言模型（LLMs） →（融入多模态能力）→ <strong>基础模型（Foundation Models）</strong>。</span></li>
                    <li><span class="highlight fact">📖 <strong>关键技术 - 自监督学习：</strong> AI模型能从无标签数据中自动生成标签进行学习，这是模型能够大规模训练的关键，因为它打破了昂贵的人工标注瓶颈。</span></li>
                    <li><span class="highlight opinion">💡 <strong>AI工程 vs. 传统ML工程：</strong>
                        <ul>
                            <li><strong>传统ML：</strong> 侧重于<strong>模型开发</strong>（特征工程、模型训练）。</li>
                            <li><strong>AI工程：</strong> 侧重于<strong>模型适配</strong>（提示工程、RAG、微调），并更接近全栈开发，强调快速产品迭代。</li>
                        </ul>
                    </span></li>
                    <li><span class="highlight fact">📖 <strong>AI工程技术栈三层：</strong> 应用开发层、模型开发层、基础设施层。当前创新的焦点主要在<strong>应用开发层</strong>。</span></li>
                     <li><span class="highlight opinion">💡 <strong>应用规划要点：</strong> 构建前需评估：<strong>1) 商业动机</strong>（是规避风险还是抓住机遇？）；<strong>2) 人机协作模式</strong>（AI是辅助还是自主决策？）；<strong>3) 产品护城河</strong>（数据、分发渠道等）；<strong>4) 设定明确的成功指标</strong>（业务指标和模型指标）。</span></li>
                </ul>
            </div>
        </details>

        <details>
            <summary>第二章：理解基础模型</summary>
            <div class="content">
                <ul>
                    <li><span class="highlight fact">📖 <strong>模型表现的三大支柱：</strong> <strong>1) 训练数据</strong>（决定了模型的能力边界和偏见）；<strong>2) 模型架构与规模</strong>（Transformer是主流，规模影响能力和成本）；<strong>3) 对齐（后训练）</strong>（使模型有用且安全）。</span></li>
                    <li><span class="highlight fact">📖 <strong>训练数据的重要性：</strong> 数据决定了模型的语言能力（如英语主导）、领域知识（如法律、医疗）和潜在偏见。低资源语言和特定领域通常需要专门的数据集。</span></li>
                    <li><span class="highlight fact">📖 <strong>后训练（Post-Training）流程：</strong>
                        <ol>
                            <li><strong>监督微调 (SFT):</strong> 使用高质量的“指令-回答”对，教会模型如何进行对话式交互，而非简单的文本补全。</li>
                            <li><strong>偏好微调 (RLHF/DPO):</strong> 使用人类（或AI）的偏好数据，进一步训练模型，使其输出更符合人类的价值观（有用、无害、诚实）。</li>
                        </ol>
                    </span></li>
                    <li><span class="highlight opinion">💡 <strong>核心洞察 - 采样的力量：</strong> 模型的输出是<strong>概率性的</strong>，而非确定性的。理解和调整采样策略（如<code>temperature</code>, <code>top-k</code>, <code>top-p</code>）是低成本提升模型性能的关键。
                        <ul>
                            <li><strong>高温 (High Temperature):</strong> 更有创意，但可能不连贯。</li>
                            <li><strong>低温 (Low Temperature):</strong> 更稳定一致，但可能乏味。</li>
                        </ul>
                    </span></li>
                    <li><span class="highlight fact">📖 <strong>AI两大“原罪”的根源：</strong> <strong>1) 不一致性</strong> 和 <strong>2) 幻觉</strong>，都源于其概率采样和自回归生成机制。模型无法区分给定的事实和自己生成的内容。</span></li>
                </ul>
            </div>
        </details>
        
        <details>
            <summary>第三、四章：评估方法论与系统评估</summary>
            <div class="content">
                <ul>
                    <li><span class="highlight opinion">💡 <strong>评估驱动开发 (Evaluation-Driven Development)：</strong> 在构建应用前，必须先定义如何衡量成功。这是将AI项目从酷炫演示推向可靠产品的关键。</span></li>
                    <li><span class="highlight fact">📖 <strong>评估的挑战：</strong> 基础模型的评估极其困难，因为它们是<strong>开放式的</strong>，没有唯一的正确答案，且很多模型是<strong>黑箱</strong>。公共基准测试（Benchmark）容易饱和或被“污染”（训练数据包含测试集）。</span></li>
                    <li><span class="highlight fact">📖 <strong>评估方法分类：</strong>
                        <ul>
                            <li><strong>精确评估：</strong> 结果明确无歧义。例如，<strong>功能正确性</strong>（代码生成是否通过单元测试）和<strong>与参考数据的相似度测量</strong>（如BLEU、ROUGE，或基于嵌入的语义相似度）。</li>
                            <li><strong>主观评估：</strong> 结果依赖评估者。最主流的是<strong>“AI作为评委 (AI as a Judge)”</strong>。</li>
                        </ul>
                    </span></li>
                    <li><span class="highlight opinion">💡 <strong>AI作为评委的利与弊：</strong>
                        <ul>
                            <li><strong>优点：</strong> 快速、成本低、可扩展、无需参考数据。在很多场景下，其判断与人类高度一致。</li>
                            <li><strong>缺点：</strong> 存在偏见（如偏爱更长、更复杂的回答，或偏爱自己模型的输出）、不一致性、标准模糊。<strong>使用时必须谨慎，并最好与精确评估或人工评估相结合。</strong></li>
                        </ul>
                    </span></li>
                    <li><span class="highlight fact">📖 <strong>模型选择流程：</strong> <strong>1) 过滤</strong>（根据许可证、隐私等硬性要求）；<strong>2) 初选</strong>（利用公共排行榜和基准初步筛选）；<strong>3) 自定义评估</strong>（使用与自己应用场景高度相关的私有数据集进行严格测试）；<strong>4) 持续监控</strong>。</span></li>
                     <li><span class="highlight opinion">💡 <strong>自建模型 vs. API：</strong> 这是一个核心决策。<strong>自建（开源模型）</strong>提供更多控制权、隐私保护和定制能力，但工程成本高。<strong>API</strong>则上手快、维护成本低，但受限于提供商、存在数据风险且灵活性较低。</span></li>
                </ul>
            </div>
        </details>

        <details>
            <summary>第五章：提示工程 (Prompt Engineering)</summary>
            <div class="content">
                <ul>
                    <li><span class="highlight fact">📖 <strong>核心概念 - 上下文学习 (In-Context Learning)：</strong> 无需更新模型权重，仅通过在提示中提供指令和示例（“shots”），就能让模型学会执行新任务。分为<strong>零样本 (Zero-shot)</strong> 和 <strong>少样本 (Few-shot)</strong>。</span></li>
                    <li><span class="highlight opinion">💡 <strong>最佳实践 - 清晰明确：</strong>
                        <ul>
                            <li><strong>明确指令：</strong> 告诉模型你想要什么，不想要什么，包括输出格式。</li>
                            <li><strong>赋予角色 (Persona)：</strong> “假设你是一位经验丰富的律师...” 能显著提升输出的质量和风格。</li>
                            <li><strong>提供示例：</strong> 这是减少歧义最有效的方法。</li>
                            <li><strong>分解任务：</strong> 将复杂任务分解为一系列简单的子任务，能提高可靠性并易于调试。</li>
                            <li><strong>给模型“思考时间”：</strong> 使用“一步一步思考 (Think step-by-step)”等短语触发<strong>思维链 (Chain-of-Thought, CoT)</strong>，能极大提升推理任务的准确性。</li>
                        </ul>
                    </span></li>
                    <li><span class="highlight fact">📖 <strong>防御性提示工程：</strong> 必须防范针对提示的攻击。
                        <ul>
                            <li><strong>提示注入 (Prompt Injection):</strong> 攻击者通过输入恶意指令，劫持应用的原始意图。</li>
                            <li><strong>越狱 (Jailbreaking):</strong> 诱导模型绕过其安全护栏，生成有害内容。</li>
                            <li><strong>信息泄露:</strong> 诱导模型泄露其系统提示或训练数据中的敏感信息。</li>
                        </ul>
                    </span></li>
                     <li><span class="highlight opinion">💡 <strong>防御策略：</strong> 在系统层面进行输入/输出过滤、对用户输入进行净化、训练模型优先遵循系统指令（指令层次结构）是比单纯依赖提示技巧更可靠的防御方式。</span></li>
                </ul>
            </div>
        </details>
        
        <details>
            <summary>第六章：RAG 与智能体 (Agents)</summary>
            <div class="content">
                 <ul>
                    <li><span class="highlight fact">📖 <strong>RAG (Retrieval-Augmented Generation)：</strong> “检索-增强-生成”模式。通过从外部知识库（如文档、数据库）中检索相关信息，并将其作为上下文提供给模型，来解决模型知识陈旧和幻觉问题。
                        <ul>
                           <li><strong>核心流程：</strong> 接收查询 → <strong>检索 (Retrieve)</strong> 相关文档 → 将文档和查询注入提示 → <strong>生成 (Generate)</strong> 答案。</li>
                           <li><strong>检索算法：</strong> 包括基于关键词的<strong>稀疏检索</strong>（如BM25）和基于语义的<strong>密集检索</strong>（向量搜索）。</li>
                        </ul>
                    </span></li>
                    <li><span class="highlight opinion">💡 <strong>RAG vs. 长上下文：</strong> RAG不会因为长上下文窗口的出现而过时。因为<strong>1) 数据量总是会超过上下文长度</strong>；<strong>2) 模型在长上下文中容易“迷失”</strong>，RAG能提供更精准的信息，从而更高效、成本更低。</span></li>
                    <li><span class="highlight fact">📖 <strong>智能体 (Agent)：</strong> 一个能够<strong>感知环境</strong>并通过<strong>使用工具</strong>来<strong>采取行动</strong>以达成目标的系统。基础模型充当智能体的“大脑”。
                        <ul>
                            <li><strong>核心循环：</strong> <strong>思考 (Thought)</strong> → <strong>行动 (Action)</strong> → <strong>观察 (Observation)</strong>。</li>
                            <li><strong>关键能力：</strong> <strong>1) 规划 (Planning)</strong> - 将复杂任务分解为可执行步骤；<strong>2) 工具使用 (Tool Use)</strong> - 调用API、执行代码、搜索网页等。</li>
                        </ul>
                    </span></li>
                    <li><span class="highlight opinion">💡 <strong>RAG是智能体的一种特例：</strong> RAG中的检索器可以被看作是智能体使用的一种工具。智能体是更通用的框架，能够执行更复杂的、多步骤的、与外部世界交互的任务。</span></li>
                     <li><span class="highlight fact">📖 <strong>记忆系统：</strong> 为了支持RAG和智能体，需要分层记忆系统：<strong>1) 内部知识</strong>（模型权重）；<strong>2) 短期记忆</strong>（上下文窗口）；<strong>3) 长期记忆</strong>（外部数据库/向量存储）。</span></li>
                </ul>
            </div>
        </details>

        <details>
            <summary>第七、八章：微调 (Finetuning) 与数据集工程</summary>
            <div class="content">
                <ul>
                    <li><span class="highlight opinion">💡 <strong>何时微调？</strong> 当提示工程和RAG都无法解决问题时，才考虑微调。
                        <ul>
                            <li><strong>RAG 解决“知识”问题：</strong> 当模型缺乏特定、动态或私有知识时。</li>
                            <li><strong>微调解决“行为”问题：</strong> 当需要模型学习特定风格、格式或非常规任务时。</li>
                        </ul>
                    </span></li>
                    <li><span class="highlight fact">📖 <strong>微调的核心挑战：</strong> <strong>内存瓶颈</strong>。完全微调一个大模型需要巨大的GPU内存，因为它不仅要存储模型权重，还要存储梯度和优化器状态。</span></li>
                    <li><span class="highlight fact">📖 <strong>关键技术 - PEFT (Parameter-Efficient Finetuning)：</strong> 只训练模型参数的一小部分（例如&lt;1%），就能达到接近全量微调的效果。
                        <ul>
                            <li><strong>LoRA (Low-Rank Adaptation):</strong> 最流行的PEFT方法。通过在现有权重矩阵旁添加并训练两个小的“低秩”矩阵来实现，推理时可以合并，不增加延迟。</li>
                            <li><strong>QLoRA:</strong> LoRA的量化版本，通过在4位精度下进行训练，进一步极大地降低了内存需求，使得在消费级GPU上微调大模型成为可能。</li>
                        </ul>
                    </span></li>
                    <li><span class="highlight opinion">💡 <strong>数据集工程的核心三要素：</strong> <strong>1) 质量 (Quality)</strong> > <strong>2) 覆盖度/多样性 (Coverage/Diversity)</strong> > <strong>3) 数量 (Quantity)</strong>。少量高质量、多样化的数据远胜于大量低质量数据。</span></li>
                    <li><span class="highlight fact">📖 <strong>数据合成 (Data Synthesis)：</strong> 使用AI模型（通常是更强大的模型）来生成训练数据。这是解决数据稀缺和标注昂贵问题的强大武器，但需要警惕<strong>模型坍塌</strong>（模型在“回声室”中不断学习自己的输出，导致多样性丧失）和<strong>质量控制</strong>问题。</span></li>
                </ul>
            </div>
        </details>

        <details>
            <summary>第九、十章：推理优化与系统架构</summary>
            <div class="content">
                <ul>
                    <li><span class="highlight fact">📖 <strong>推理的两个阶段与瓶颈：</strong>
                        <ul>
                            <li><strong>Prefill (提示处理):</strong> 并行处理输入提示，是<strong>计算密集型 (Compute-bound)</strong>。</li>
                            <li><strong>Decode (解码/生成):</strong> 逐个生成Token，是<strong>内存带宽密集型 (Memory-bound)</strong>。</li>
                        </ul>
                    </span></li>
                    <li><span class="highlight opinion">💡 <strong>核心优化技术：</strong>
                        <ul>
                            <li><strong>量化 (Quantization):</strong> 使用更低的数据精度（如FP16, INT8, INT4）来存储模型权重，能极大减少内存占用和加速计算。</li>
                            <li><strong>投机性解码 (Speculative Decoding):</strong> 用一个小的“草稿”模型快速生成一段文本，再由大模型一次性验证，从而加速解码过程。</li>
                            <li><strong>PagedAttention & KV缓存优化：</strong> 像操作系统的虚拟内存一样管理KV缓存，显著提高GPU利用率和吞吐量。</li>
                            <li><strong>批处理 (Batching):</strong> 将多个请求合并处理。<strong>持续批处理 (Continuous Batching)</strong> 是当前最先进的技术，能有效处理不同长度的请求序列。</li>
                        </ul>
                    </span></li>
                    <li><span class="highlight fact">📖 <strong>通用AI工程架构演进：</strong>
                        <ol>
                            <li><strong>基础调用：</strong> 应用 → 模型API。</li>
                            <li><strong>增强上下文：</strong> 引入RAG和工具使用。</li>
                            <li><strong>增加护栏：</strong> 加入输入/输出安全检查和内容审核。</li>
                            <li><strong>引入路由/网关：</strong> 统一管理对多个模型的调用，实现成本控制、负载均衡和故障转移。</li>
                            <li><strong>优化性能：</strong> 增加缓存层（精确缓存、语义缓存）。</li>
                            <li><strong>实现复杂逻辑：</strong> 引入智能体模式和多步工作流。</li>
                        </ol>
                    </span></li>
                    <li><span class="highlight opinion">💡 <strong>用户反馈是数据飞轮的核心：</strong> AI应用的独特之处在于，用户反馈不仅能改进产品，还能直接作为数据来迭代模型。设计无缝、低摩擦的反馈机制（如点赞/点踩、编辑建议、对话信号分析）至关重要。</span></li>
                </ul>
            </div>
        </details>

    </div>

<div class="attachments-panel" id="attachments-panel">
    <h3>原文</h3>
    <a href="book_AI_engineering_files/book.html" target="_blank">源链接</a>
</div>
<button class="float-toggle" id="float-toggle" title="打开附件面板">◁</button>
<script>
// 浮动框展开/收起功能
document.addEventListener('DOMContentLoaded', function() {
    const panel = document.getElementById('attachments-panel');
    const toggleBtn = document.getElementById('float-toggle');
    
    if (!panel || !toggleBtn) return;
    
    // 切换面板显示状态
    function togglePanel() {
        panel.classList.toggle('expanded');
        // 更新按钮图标
        const isExpanded = panel.classList.contains('expanded');
        toggleBtn.textContent = isExpanded ? '▷' : '◁';
        toggleBtn.title = isExpanded ? '关闭附件面板' : '打开附件面板';
        
        // 动态调整按钮位置
        if (isExpanded) {
            // 等待面板展开动画完成后调整按钮位置
            setTimeout(() => {
                const panelWidth = panel.offsetWidth;
                toggleBtn.style.right = (panelWidth + 30) + 'px';
            }, 300);
        } else {
            toggleBtn.style.right = '10px';
        }
    }
    
    // 点击切换按钮
    toggleBtn.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        togglePanel();
    });
    
    // 点击页面其他地方时收起面板
    document.addEventListener('click', function(e) {
        const isClickOnPanel = panel.contains(e.target);
        const isClickOnToggle = toggleBtn.contains(e.target);
        
        if (!isClickOnPanel && !isClickOnToggle) {
            panel.classList.remove('expanded');
            toggleBtn.textContent = '◁';
            toggleBtn.title = '打开附件面板';
            toggleBtn.style.right = '10px'; // 重置按钮位置
        }
    });
    
    // ESC键关闭面板
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && panel.classList.contains('expanded')) {
            panel.classList.remove('expanded');
            toggleBtn.textContent = '◁';
            toggleBtn.title = '打开附件面板';
            toggleBtn.style.right = '10px'; // 重置按钮位置
        }
    });
});
</script>
</body>
</html>