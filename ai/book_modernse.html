<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>《现代软件工程》核心摘要：超轻认知负荷版</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f8f8f8;
            color: #333;
            margin: 0;
            padding: 20px;
            line-height: 1.6;
        }
        .container {
            max-width: 900px;
            margin: auto;
            background-color: #fff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }
        h1, h2, h3, h4 {
            color: #222;
            margin-bottom: 10px;
        }
        h1 {
            font-size: 2.2em;
            text-align: center;
            margin-bottom: 25px;
            color: #0056b3;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 15px;
        }
        h2 {
            font-size: 1.8em;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 8px;
            margin-top: 30px;
        }
        h3 {
            font-size: 1.4em;
            color: #444;
            margin-top: 20px;
        }
        p {
            margin-bottom: 10px;
        }
        strong {
            color: #0056b3; /* 事实和定义的蓝色 */
            background-color: #e6f2ff;
            padding: 2px 4px;
            border-radius: 3px;
        }
        em {
            color: #28a745; /* 观点和核心概念的绿色 */
            background-color: #e9ffee;
            padding: 2px 4px;
            border-radius: 3px;
            font-style: normal; /* 消除默认的斜体 */
        }
        .ai-ml {
            background-color: #fff0e6; /* AI/ML内容的橙色背景 */
            border-left: 5px solid #ff9933;
            padding: 10px 15px;
            margin: 15px 0;
            border-radius: 5px;
            color: #8B4513; /* 深棕色文字 */
        }
        .intro-text {
            font-size: 1.1em;
            margin-bottom: 25px;
            padding: 10px 0;
            border-bottom: 1px solid #eee;
        }

        /* Accordion Styles */
        .accordion-header {
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            padding: 15px 20px;
            width: 100%;
            border: none;
            text-align: left;
            outline: none;
            font-size: 1.1em;
            transition: background-color 0.3s ease, border-radius 0.3s ease;
            border-bottom: 1px solid #ddd;
            border-top-left-radius: 5px;
            border-top-right-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .accordion-header:hover {
            background-color: #e0e0e0;
        }
        .accordion-header.active {
            background-color: #d0d0d0;
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }
        .accordion-content {
            padding: 0 18px;
            background-color: white;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-out, padding 0.4s ease-out;
            border-left: 1px solid #ddd;
            border-right: 1px solid #ddd;
            border-bottom: 1px solid #ddd;
            border-bottom-left-radius: 5px;
            border-bottom-right-radius: 5px;
        }
        .accordion-content.show {
            max-height: 2000px; /* Adjust as needed for content height */
            padding: 15px 18px;
        }
        .arrow {
            font-size: 0.8em;
            transition: transform 0.3s ease;
            margin-left: 10px;
        }
        .accordion-header.active .arrow {
            transform: rotate(90deg);
        }

        /* Nested Accordion Styles */
        .nested-accordion-header {
            background-color: #fafafa;
            color: #555;
            cursor: pointer;
            padding: 12px 15px;
            width: 100%;
            border: none;
            text-align: left;
            outline: none;
            font-size: 1em;
            transition: background-color 0.3s ease;
            border-bottom: 1px dashed #eee;
            margin-top: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .nested-accordion-header:hover {
            background-color: #f0f0f0;
        }
        .nested-accordion-header.active {
            background-color: #e5e5e5;
        }
        .nested-accordion-content {
            padding: 0 10px 0 30px;
            background-color: white;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
        }
        .nested-accordion-content.show {
            max-height: 1000px; /* Adjust as needed for content height */
            padding: 10px 10px 10px 30px;
        }
        .nested-arrow {
            font-size: 0.7em;
            transition: transform 0.3s ease;
            margin-left: 8px;
        }
        .nested-accordion-header.active .nested-arrow {
            transform: rotate(90deg);
        }
        ul {
            list-style-type: disc;
            margin-left: 20px;
            padding-left: 0;
        }
        ul ul {
            list-style-type: circle;
            margin-left: 20px;
        }
        li {
            margin-bottom: 5px;
        }
    /* 主容器布局调整 - 移除flex布局以保持原始排版 */

.attachments-panel {
    width: 250px;
    background: #fff;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    height: fit-content;
    position: sticky;
    top: 20px;
    flex-shrink: 0;
    z-index: 1000;
    border: 1px solid #e0e0e0;
}
.attachments-panel h3 {
    color: #004085;
    margin-top: 0;
    margin-bottom: 15px;
    text-align: center;
    border-bottom: 2px solid #004085;
    padding-bottom: 10px;
}
.attachment-item {
    background-color: #f8f9fa;
    border: 1px solid #ced4da;
    border-radius: 5px;
    padding: 15px;
    margin-bottom: 15px;
    transition: all 0.3s ease;
}
.attachment-item:hover {
    background-color: #e9ecef;
    border-color: #004085;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}
.attachment-item h4 {
    margin: 0 0 8px 0;
    color: #004085;
    font-size: 14px;
}
.attachment-item p {
    margin: 0 0 10px 0;
    font-size: 12px;
    color: #6c757d;
    line-height: 1.4;
}
.download-btn {
    display: inline-block;
    background-color: #28a745;
    color: white;
    text-decoration: none;
    padding: 8px 16px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: bold;
    transition: background-color 0.3s ease;
    width: 100%;
    text-align: center;
    box-sizing: border-box;
}
.download-btn:hover {
    background-color: #218838;
    text-decoration: none;
    color: white;
}
.download-btn:before {
    content: "▼ ";
    margin-right: 5px;
}

/* 可折叠浮动框样式 */
.attachments-panel {
    position: fixed;
    top: 10px;
    right: 10px;
    width: auto; /* 自适应宽度 */
    min-width: 250px; /* 最小宽度 */
    max-width: calc(100vw - 60px); /* 最大宽度，留出边距 */
    max-height: calc(100vh - 80px); /* 留出更多空间避免滚动条 */
    overflow-y: auto;
    overflow-x: hidden; /* 隐藏横向滚动条 */
    z-index: 9999;
    box-shadow: 0 8px 24px rgba(0,0,0,0.25);
    border: 2px solid #004085;
    transform: translateX(100%); /* 默认完全隐藏 */
    transition: transform 0.3s ease;
    /* 自定义滚动条样式 */
    scrollbar-width: thin;
    scrollbar-color: #004085 #f0f0f0;
}

/* WebKit浏览器滚动条样式 */
.attachments-panel::-webkit-scrollbar {
    width: 6px;
}

.attachments-panel::-webkit-scrollbar-track {
    background: #f0f0f0;
    border-radius: 3px;
}

.attachments-panel::-webkit-scrollbar-thumb {
    background: #004085;
    border-radius: 3px;
}

.attachments-panel::-webkit-scrollbar-thumb:hover {
    background: #0056b3;
}

/* 展开时显示 */
.attachments-panel.expanded {
    transform: translateX(0);
}

/* 移除container的margin-right设置，保持原始布局 */

.attachment-item {
    width: 250px;
    margin-right: 0;
    display: block;
    margin-bottom: 12px;
    white-space: nowrap; /* 防止文本换行导致宽度过大 */
}

.attachment-item h4 {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis; /* 长文本显示省略号 */
    max-width: 100%;
}

.attachments-panel h3 {
    font-size: 16px;
    margin-bottom: 12px;
    white-space: nowrap; /* 标题不换行 */
}

.attachments-panel a {
    white-space: nowrap; /* 链接文本不换行 */
    overflow: hidden;
    text-overflow: ellipsis;
    display: inline-block;
    max-width: 100%;
}

/* 浮动切换按钮 */
.float-toggle {
    position: fixed;
    top: 10px;
    right: 10px;
    width: 50px;
    height: 50px;
    background: #004085;
    color: white;
    border: none;
    border-radius: 50%;
    font-size: 20px;
    cursor: pointer;
    z-index: 10000;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

.float-toggle:hover {
    background: #0056b3;
    transform: scale(1.1);
}

.float-toggle:active {
    transform: scale(0.95);
}

/* 当面板展开时，按钮位置动态调整 */
.attachments-panel.expanded ~ .float-toggle {
    right: 20px; /* 保持在面板左侧的固定位置 */
    opacity: 0.7; /* 展开时降低透明度，避免遮挡 */
}
    </style>
</head>
<body>
    <div class="container">
        <h1>《现代软件工程：做有效之事以更快更好地构建软件》核心摘要</h1>
        <p class="intro-text">
            本书深入探讨了现代软件工程的核心原则和实践，旨在帮助读者以更高效、更高质量的方式构建软件。本摘要将以超轻认知负荷的方式，提炼并高亮其中的<strong>核心事实</strong>和<em>关键观点</em>，并特别关注<strong>AI/ML相关内容</strong>。
        </p>

        <!-- 第一部分 -->
        <button class="accordion-header">
            第一部分：什么是软件工程？ <span class="arrow">&#9658;</span>
        </button>
        <div class="accordion-content">
            <h3>第一章：引言</h3>
            <ul>
                <li>软件开发是<strong>发现和探索</strong>的过程，软件工程师需成为<em>学习的专家</em>。</li>
                <li>工程是<strong>科学的实践应用</strong>，其核心方法是：<strong>描述、假设、预测、实验</strong>。</li>
                <li><strong>软件工程的定义：</strong><em>将经验主义和科学方法应用于寻找软件实际问题的有效、经济解决方案。</em></li>
                <li>核心支柱：成为<strong>学习的专家</strong>（迭代、反馈、增量、实验、经验）和<strong>管理复杂性的专家</strong>（模块化、内聚、关注点分离、抽象、松耦合）。</li>
                <li>软件工程不应是官僚主义或僵化的，而应是<strong>“行之有效的方法”</strong>，它能<em>更快更好地构建软件</em>。</li>
                <li>历史上的<strong>“软件危机”</strong>促使了“软件工程”概念的诞生（Margaret Hamilton，NATO会议）。</li>
                <li>软件进步慢于硬件是<em>一个持久的现象</em>（Fred Brooks的“没有银弹”）。</li>
                <li>需要思维上的<strong>范式转变</strong>：从“事先完美计划”到“接受错误并快速学习适应”。</li>
            </ul>

            <h3>第二章：什么是工程？</h3>
            <ul>
                <li>软件工程不是<strong>生产工程</strong>（数字产品的生产成本几乎为零），而是<strong>设计工程</strong>。</li>
                <li>设计工程是<strong>探索性、创造性</strong>的，与物理世界不同，软件模型本身就是产品，可<strong>精确验证</strong>。</li>
                <li>工程不等于代码：工程是<strong>创造软件的整个过程</strong>，包括流程、工具、文化。</li>
                <li>工程之所以重要：
                    <ul>
                        <li>克服<strong>“工匠”的局限性</strong>：工匠模式难以实现<strong>高精度和可伸缩性</strong>，每次产品都是唯一的。</li>
                        <li>工程通过<strong>工具和自动化实现超人精度和可伸缩性</strong>（例如自动化测试比人工测试快百万倍）。</li>
                        <li>有效<strong>管理复杂性</strong>：通过<strong>模块化、组件化</strong>等方式将大问题分解成可管理的小部分。</li>
                        <li>强调<strong>可重复性和测量精度</strong>：精确测量能更快发现问题（例如水管漏水例子）。</li>
                    </ul>
                </li>
                <li><em>现代软件工程的决策应基于<strong>理性标准和证据</strong>，而非直觉或信仰。</em></li>
                <li><strong>权衡</strong>：所有工程都是优化和权衡的博弈，例如安全性与易用性，分布式与集成成本。</li>
                <li><strong>进步的幻觉</strong>：<em>很多技术变革（如特定语言、框架）并未带来根本性进步</em>。真正重要的是<strong>底层设计原则</strong>（如Serverless因鼓励模块化和关注点分离而重要）。</li>
                <li>从工匠到工程的转变：<strong>工程是工匠精神与科学理性相结合</strong>，它放大创造力、降低成本、提供更健壮灵活的解决方案。</li>
            </ul>

            <h3>第三章：工程方法的基石</h3>
            <ul>
                <li>软件行业的变化常是<strong>短暂的</strong>，真正的进步速度<em>远低于预期</em>（例如多数语言改变未带来10倍提升）。</li>
                <li><strong>测量的核心重要性：</strong>
                    <ul>
                        <li>多数软件开发指标无效或有害（如速度、代码行数）。</li>
                        <li><strong>DORA研究</strong>（Nicole Forsgren, Jez Humble, Gene Kim）提供了<strong>有效衡量</strong>：<strong>稳定性</strong>（变更失败率、恢复时间）和<strong>吞吐量</strong>（交付周期、部署频率）。</li>
                        <li><em>高绩效团队在稳定性和吞吐量上表现优异，且与组织绩效和商业成功相关。</em></li>
                        <li><em>速度和质量不是权衡关系，而是<strong>正相关</strong>。</em></li>
                        <li><strong>证据驱动决策：</strong>例如，<strong>变更审批委员会（CAB）实际上会降低稳定性，拖慢速度</strong>。</li>
                    </ul>
                </li>
                <li><strong>软件工程学科的基石：</strong>
                    <ul>
                        <li>成为<strong>学习的专家</strong>：<strong>迭代、反馈、增量、实验、经验。</strong></li>
                        <li>成为<strong>管理复杂性的专家</strong>：<strong>模块化、内聚、关注点分离、抽象、松耦合。</strong></li>
                    </ul>
                </li>
                <li><em>这些原则相互关联，而非独立。它们提供了超越工具和技术、指导决策的持久框架。</em></li>
            </ul>
        </div>

        <!-- 第二部分 -->
        <button class="accordion-header">
            第二部分：优化学习 <span class="arrow">&#9658;</span>
        </button>
        <div class="accordion-content">
            <h3>第四章：迭代工作</h3>
            <ul>
                <li><strong>迭代的定义：</strong><em>通过重复操作序列逐步逼近期望结果的过程。</em>它驱动学习、允许纠错和适应。</li>
                <li><strong>敏捷革命：</strong>敏捷宣言核心思想是<strong>“检查与适应”</strong>，接受必然犯错，并降低犯错成本。这是一种<strong>科学思维</strong>。</li>
                <li><strong>迭代的实践优势：</strong>
                    <ul>
                        <li>自然缩小批次大小，鼓励<strong>模块化和关注点分离</strong>。</li>
                        <li>提供<strong>确定性反馈</strong>，加快学习周期。</li>
                    </ul>
                </li>
                <li><strong>迭代作为防御性设计策略：</strong>
                    <ul>
                        <li>传统瀑布模型假设变更成本随时间增加（错误假设）。</li>
                        <li>敏捷目标是<strong>“扁平化变更成本曲线”</strong>：无论何时发生变更，成本都大致相同。</li>
                        <li>这允许在项目早期知识最少时做出关键决策，并在后续持续学习和适应。</li>
                    </ul>
                </li>
                <li><strong>计划的诱惑：</strong>瀑布模型的“预先周密计划”在数字世界不成立。<em>行业数据表明，三分之二的产品构想零价值或负价值。</em></li>
                <li><strong>无限的开端：</strong>迭代方法是<strong>无边界、进化式</strong>的。瀑布是有限的。</li>
                <li><strong>迭代的实用性：</strong>从小批次开始工作。<strong>持续集成（CI）</strong>和<strong>测试驱动开发（TDD）</strong>是精细粒度的迭代过程。</li>
            </ul>

            <h3>第五章：反馈</h3>
            <ul>
                <li><strong>反馈的定义：</strong><em>关于行动、事件或过程的评价性或纠正性信息传回源头。</em><strong>没有反馈就没有学习。</strong></li>
                <li><strong>反馈的重要性：</strong>
                    <ul>
                        <li><strong>平衡扫帚的例子</strong>：规划式（不稳） vs. 反馈式（稳定）。软件开发环境变化，需反馈。</li>
                        <li><strong>NATO会议洞见</strong>：早期就认识到反馈回路、测试环境、模块化对软件工程的重要性。</li>
                    </ul>
                </li>
                <li><strong>在代码中获取反馈：</strong>
                    <ul>
                        <li><strong>TDD</strong>：先写测试（红），然后写代码使其通过（绿），再重构。提供<strong>秒级甚至毫秒级</strong>的快速反馈。</li>
                    </ul>
                </li>
                <li><strong>在集成中获取反馈：</strong>
                    <ul>
                        <li><strong>持续集成（CI）</strong>：频繁提交代码到共享主线，每天多次。每次提交都触发系统评估。</li>
                        <li><strong>CI vs. 特性分支（FB）</strong>：FB隔离变更，延迟集成，导致“合并地狱”。CI旨在尽早暴露变更，提供更早、更频繁的反馈。</li>
                    </ul>
                </li>
                <li><strong>在设计中获取反馈：</strong>
                    <ul>
                        <li><strong>TDD</strong>：<em>测试难写通常意味着设计糟糕。</em>TDD迫使代码具备<strong>模块化、关注点分离、高内聚、信息隐藏、恰当耦合</strong>等高质量特性。</li>
                        <li><strong>测试的重要性</strong>：软件对缺陷极其敏感。TDD将测试置于开发核心，缩短反馈周期至数秒。</li>
                    </ul>
                </li>
                <li><strong>在架构中获取反馈：</strong>
                    <ul>
                        <li><strong>持续交付（CD）</strong>要求软件始终可发布，这意味着它必须<strong>易于部署</strong>。</li>
                        <li><em>高可测试性/可部署性促进了<strong>更模块化、更好抽象、更松耦合的设计</strong>（如微服务）。</em></li>
                    </ul>
                </li>
                <li><strong>优先选择早期反馈：</strong><strong>“快速失败”（Fail fast）</strong>或“左移”（Shift-left）。在编译、单元测试、更高层级测试中尽早发现问题。</li>
                <li><strong>在产品设计中获取反馈：</strong>
                    <ul>
                        <li><em>真正的产品价值只有通过用户/客户的<strong>反馈才能确定</strong>。</em></li>
                        <li><strong>持续交付</strong>的真正价值是闭合从构思到生产的反馈循环，从而更快地学习并适应市场。</li>
                        <li><strong>遥测（Telemetry）</strong>：从生产系统收集数据，诊断问题并指导产品设计，将“IT部门”转变为“数字化业务”。</li>
                    </ul>
                </li>
                <li><strong>在组织和文化中获取反馈：</strong>
                    <ul>
                        <li>传统软件衡量指标（LOC、开发日、测试覆盖率）无效。</li>
                        <li><strong>DORA度量（稳定性、吞吐量）</strong>提供了有意义的反馈。</li>
                        <li><em>高稳定性+高吞吐量的团队更成功、更赚钱。<strong>速度与质量是正相关而非权衡</strong>。</em></li>
                        <li>可以像科学家一样，设定当前状态和目标状态，进行小步实验来衡量变更效果。</li>
                    </ul>
                </li>
            </ul>
        </div>

        <!-- 第三部分 -->
        <button class="accordion-header">
            第三部分：优化复杂性管理 <span class="arrow">&#9658;</span>
        </button>
        <div class="accordion-content">
            <h3>第九章：模块化</h3>
            <ul>
                <li><strong>模块化的定义：</strong><em>系统组件可被分离和重组的程度，常带来灵活性和多样性。</em></li>
                <li>模块化是<strong>管理复杂性</strong>的关键。现代系统太大，需分解为可理解的小块。</li>
                <li><strong>模块化的特征：</strong>可重用、独立理解、有内部和外部概念、有清晰接口。</li>
                <li><strong>低估设计的重要性：</strong><em>行业过于痴迷语言和框架，忽视了设计原则（如模块化、关注点分离）的核心价值。</em></li>
                <li><strong>可测试性的核心作用：</strong><em>可测试性直接驱动模块化。</em>如果测试代码很困难，则设计很糟糕。</li>
                <li><strong>为可测试性而设计：</strong>
                    <ul>
                        <li><strong>“风洞实验”类比</strong>：通过隔离被测组件，控制变量，获得精确可重复的测试结果。</li>
                        <li><strong>精确测量</strong>：测试结果应是<strong>确定性</strong>的。</li>
                        <li><strong>测量点</strong>：设计系统时就考虑插入探针来注入数据和收集输出。</li>
                        <li><em>通过<strong>依赖注入</strong>和<strong>良好模块设计</strong>，可使代码更可测试，进而更灵活、更具可替换性。</em></li>
                    </ul>
                </li>
                <li><strong>服务与模块化：</strong>
                    <ul>
                        <li><strong>服务</strong>是<strong>信息隐藏</strong>的组织概念，代表着系统中的边界。</li>
                        <li>这些边界应被视为<strong>翻译和验证点</strong>，而不是简单透传。</li>
                    </ul>
                </li>
                <li><strong>可部署性与模块化：</strong>
                    <ul>
                        <li><strong>持续交付（CD）</strong>要求软件始终可发布，这意味着它必须<strong>易于部署</strong>。</li>
                        <li><strong>部署流水线</strong>的有效范围是<strong>“独立可部署的软件单元”</strong>。</li>
                        <li><em>这促进了<strong>微服务</strong>架构，因为微服务天生就是独立可部署的。</em></li>
                        <li><em>微服务是<strong>组织可伸缩性</strong>的模式，旨在解耦团队，但需以更复杂分布式架构为代价。</em></li>
                    </ul>
                </li>
                <li><strong>不同尺度的模块化：</strong>从企业系统到单个方法，模块化理念都是<strong>分形（fractal）</strong>的。</li>
                <li><strong>人类系统中的模块化：</strong>
                    <ul>
                        <li><strong>Conway定律</strong>：组织结构影响系统设计。</li>
                        <li><em>模块化组织（如Amazon的“双披萨团队”）通过解耦团队，实现了前所未有的创新速度和可伸缩性。</em></li>
                    </ul>
                </li>
            </ul>

            <h3>第十章：内聚</h3>
            <ul>
                <li><strong>内聚的定义（计算机科学）：</strong><em>模块内元素相互关联的程度。</em></li>
                <li><strong>模块化与内聚：设计基础。</strong>
                    <ul>
                        <li>Kent Beck：“将不相关的拉远，将相关的放近。”</li>
                        <li>模块化是分隔，内聚是聚合。</li>
                    </ul>
                </li>
                <li><strong>代码中的内聚：</strong>
                    <ul>
                        <li>通过将紧密相关的代码（如读取、处理、存储）放到独立的、命名的函数中，可提高内聚和可读性。</li>
                        <li><em>代码的主要目标是<strong>向人类交流思想</strong>，而非追求字符最少。</em></li>
                    </ul>
                </li>
                <li><strong>上下文的重要性：</strong>内聚是情境化的概念，与模块化和关注点分离紧密交织。</li>
                <li><strong>高内聚软件的实现：</strong>
                    <ul>
                        <li>通过<strong>DDD（领域驱动设计）</strong>，让设计遵循问题领域，识别“有界上下文”来划分模块。</li>
                        <li><strong>TDD</strong>：<em>编写测试时，如果代码没有高内聚，测试会变得困难，从而反向推动设计改进。</em></li>
                        <li><strong>分离意外复杂性与核心复杂性</strong>：有助于提升内聚。</li>
                    </ul>
                </li>
                <li><strong>低内聚的代价：</strong>
                    <ul>
                        <li>代码和系统<strong>灵活性差、难以测试、难以维护</strong>。</li>
                        <li>导致“大泥球”代码，成为“遗留代码”。</li>
                        <li>识别低内聚的简单方法：阅读代码时感到“不知道这段代码在做什么”。</li>
                    </ul>
                </li>
                <li><strong>人类系统中的内聚：</strong>高绩效团队通常在内部信息和技能上高度内聚，具备<strong>自主决策能力</strong>，无需外部许可。</li>
            </ul>

            <h3>第十一章：关注点分离</h3>
            <ul>
                <li><strong>关注点分离的定义：</strong><em>将计算机程序分解为独立的部分，每个部分处理一个独立的关注点。</em></li>
                <li>这是<em>个人工作中<strong>最强大的设计原则</strong></em>，是提升模块化、内聚、抽象和降低耦合的关键技术。</li>
                <li><strong>数据库替换案例：</strong><em>通过严格的关注点分离，将数据库从商业逻辑中解耦，使得更换数据库从数月工作变为数小时。</em></li>
                <li><strong>示例代码分析：</strong>
                    <ul>
                        <li>混合“核心逻辑”与“数据库存储细节”是糟糕的分离。</li>
                        <li>通过<strong>依赖注入</strong>和<strong>抽象</strong>，可以将存储逻辑解耦，使核心业务逻辑更纯粹。</li>
                        <li>选择哪种分离方式取决于上下文和权衡（如同步与异步）。</li>
                    </ul>
                </li>
                <li><strong>依赖注入：</strong>通过参数而非内部创建来提供依赖，是实现关注点分离和降低耦合的<strong>极其有用工具</strong>。</li>
                <li><strong>分离核心复杂性与意外复杂性：</strong>
                    <ul>
                        <li><strong>核心复杂性</strong>：问题本身固有的复杂性（如计算账户价值）。</li>
                        <li><strong>意外复杂性</strong>：因使用计算机而引入的复杂性（如数据持久化、屏幕显示、并发、安全）。</li>
                        <li><em>通过清晰地划分这两类关注点，可显著改善设计，提高可测试性。</em></li>
                    </ul>
                </li>
                <li><strong>DDD的重要性：</strong>通过<strong>领域驱动设计</strong>，可以从问题领域本身识别出自然的关注点分离边界。</li>
                <li><strong>可测试性：</strong><em>可测试性是实现有效关注点分离的<strong>强大工具</strong>。</em>如果代码难以测试，往往是关注点混淆所致。</li>
                <li><strong>端口与适配器模式：</strong>
                    <ul>
                        <li>一种将核心业务逻辑与外部技术细节（如数据库、网络）隔离的设计模式。</li>
                        <li>核心逻辑通过“端口”与抽象接口交互，具体技术通过“适配器”实现。</li>
                        <li><em>这种模式在服务边界处尤其重要，因为它强制进行信息翻译和验证，有效<strong>隔离变更影响</strong>。</em></li>
                    </ul>
                </li>
                <li><strong>API是什么？</strong>API是所有暴露给消费者的信息，包括数据结构和行为。设计API时，需考虑其暴露的粒度，并进行适当的封装和验证。</li>
                <li><strong>TDD驱动关注点分离：</strong><em>TDD通过迫使先写测试，促使开发者设计出<strong>高可测试性、关注点分离清晰</strong>的代码。</em>测试的难度可作为设计质量的早期反馈。</li>
                <li><strong>总结：</strong>关注点分离是可操作性最强的设计启发式方法，能明确指导代码设计，使其更易理解、测试、修改和扩展。</li>
            </ul>

            <h3>第十二章：信息隐藏与抽象</h3>
            <ul>
                <li><strong>信息隐藏与抽象的定义：</strong><em>在研究对象或系统时，去除物理、空间或时间细节或属性，以关注更重要的细节。</em></li>
                <li>核心目的是<strong>管理复杂性</strong>：通过在代码中划定“界限”，隐藏实现细节，使开发者可专注于当前工作。</li>
                <li><strong>“大泥球”的原因：</strong>
                    <ul>
                        <li><strong>组织和文化问题：</strong>开发者未能履行“专业职责”，未能有效管理代码质量。<em>低质量软件长期来看<strong>更慢、成本更高</strong>。</em></li>
                        <li><strong>技术和设计问题：</strong>对现有代码缺乏修改意愿或能力（“死代码”）。<em>拥抱变化是关键。</em></li>
                    </ul>
                </li>
                <li><strong>抽象的力量：</strong>
                    <ul>
                        <li>操作系统抽象了硬件，云服务抽象了分布式系统。</li>
                        <li>“纯文本”生态系统、Unix的文件模型都是强大的抽象。</li>
                        <li><em>软件开发本质上就是在<strong>创造新的抽象</strong>。</em></li>
                    </ul>
                </li>
                <li><strong>泄漏的抽象：</strong>
                    <ul>
                        <li><em>“所有非琐碎的抽象都会泄漏。”</em> 这并非反对抽象，而是提醒需谨慎管理。</li>
                        <li>分为<strong>无法避免的泄漏</strong>（如并发、内存访问时间）和<strong>因设计不足造成的泄漏</strong>（如业务逻辑返回技术错误码）。</li>
                        <li>目标是<strong>最小化泄漏影响</strong>，保持抽象的一致性。</li>
                    </ul>
                </li>
                <li><strong>选择恰当的抽象：</strong>
                    <ul>
                        <li>地图类比：不同的抽象服务于不同的目的（如航海图 vs. 地铁图）。</li>
                        <li><em>测试性可提供早期反馈，帮助识别抽象的脆弱性。</em></li>
                    </ul>
                </li>
                <li><strong>从问题领域抽象：</strong>利用<strong>事件风暴</strong>等技术识别问题领域中的自然关注点分离。</li>
                <li><strong>抽象意外复杂性：</strong>
                    <ul>
                        <li>将处理计算机细节的代码与核心业务逻辑分离。</li>
                        <li>通过<strong>抽象接口和依赖注入</strong>，使业务逻辑不依赖具体技术实现（如数据库）。</li>
                        <li><em>这是在代码中隔离第三方代码的关键策略。</em></li>
                    </ul>
                </li>
                <li><strong>始终优先隐藏信息：</strong>
                    <ul>
                        <li>选择更通用的表示而非过分具体（如使用List而非ArrayList）。</li>
                        <li><em>这有助于保持代码的灵活性，为未来的变更保留开放选项。</em></li>
                        <li><strong>TDD</strong>是促进信息隐藏和抽象的最强大工具，它迫使你从外部视角设计接口。</li>
                    </ul>
                </li>
            </ul>
        </div>

        <!-- 第四部分 -->
        <button class="accordion-header">
            第四部分：支持工程的工具 <span class="arrow">&#9658;</span>
        </button>
        <div class="accordion-content">
            <h3>第十四章：工程学科的工具</h3>
            <ul>
                <li>真正的软件工程应关注<strong>结果</strong>：<em>更快更好地构建软件。</em></li>
                <li>软件开发不仅仅是代码：需要<strong>测试</strong>来验证其工作原理，因为人类容易犯错且倾向于看到预期结果。</li>
                <li><strong>可测试性是工具：</strong>
                    <ul>
                        <li><strong>依赖注入</strong>是实现可测试性的关键，它使代码更<strong>模块化、内聚、关注点分离、抽象和恰当耦合</strong>。</li>
                        <li><strong>测量点：</strong>设计系统时就考虑如何注入测试数据和收集结果。</li>
                        <li><strong>挑战：</strong>系统边缘（与真实硬件交互）的测试性较差；文化问题（“我们尝试了TDD，但它不起作用”）。</li>
                        <li><strong>TDD</strong>是鼓励良好设计的基石，<em>它能放大开发者的技能和经验。</em></li>
                    </ul>
                </li>
                <li><strong>可部署性：</strong>
                    <ul>
                        <li><strong>持续交付（CD）</strong>的核心是使软件<strong>始终处于可发布状态</strong>。</li>
                        <li><strong>部署流水线</strong>是验证可发布性的机制。</li>
                        <li><em>部署流水线的有效范围是<strong>“独立可部署的软件单元”</strong>。</em></li>
                        <li>这迫使团队在系统级别重视模块化、内聚、关注点分离、抽象和松耦合。</li>
                    </ul>
                </li>
                <li><strong>速度：</strong>
                    <ul>
                        <li><strong>反馈的速度和质量</strong>是优化学习的关键。</li>
                        <li><strong>吞吐量</strong>衡量开发效率。</li>
                        <li><strong>目标：</strong>从提交到可生产部署，通常建议<strong>小于1小时</strong>。</li>
                        <li><em>对速度的关注会自然驱动团队采纳敏捷、精益、CD和DevOps的实践。</em></li>
                    </ul>
                </li>
                <li><strong>控制变量：</strong>
                    <ul>
                        <li>要实现快速、可靠、可重复的测试和部署，必须<strong>控制变量</strong>。</li>
                        <li>通过<strong>自动化部署、基础设施即代码、版本控制</strong>等来管理配置。</li>
                        <li><em>长期运行或手动测试通常是未能控制变量的症状。</em></li>
                        <li>软件系统是确定性的（除了并发）。设计可测试的代码会使代码更确定性、更易理解、更高效。</li>
                    </ul>
                </li>
                <li><strong>持续交付：</strong>
                    <ul>
                        <li>一种<strong>组织哲学</strong>，将上述所有思想整合为有效的工作方法。</li>
                        <li>它<strong>迫使组织结构扁平化、解耦团队，提升自动化（尤其测试），鼓励可测试设计</strong>。</li>
                        <li><em>持续交付是构建<strong>强大软件工程学科</strong>的高效策略。</em></li>
                    </ul>
                </li>
                <li><strong>通用工程工具：</strong>
                    <ul>
                        <li>评估第三方技术时，可使用这些原则作为标准：它<strong>可部署、可测试、可控制变量、足够快（用于CD）、支持模块化</strong>吗？</li>
                        <li><em>这些工具提供了<strong>证据驱动</strong>的决策模型，而非依赖时尚或猜测。</em></li>
                    </ul>
                </li>
            </ul>
        </div>

        <!-- 第十五章 -->
        <button class="accordion-header">
            第十五章：现代软件工程师 <span class="arrow">&#9658;</span>
        </button>
        <div class="accordion-content">
            <ul>
                <li>本书所有概念（模块化、内聚、关注点分离等）<strong>相互关联且无处不在</strong>。它们是超越特定工具、语言和框架的<strong>通用技能</strong>。</li>
                <li>核心目标：<strong>优化学习</strong>和<strong>管理复杂性</strong>，这是软件工程学科的基础。</li>
                <li>软件工程是<strong>人类过程</strong>：
                    <ul>
                        <li><strong>定义：</strong><em>将经验主义和科学方法应用于寻找软件实际问题的有效、经济解决方案。</em></li>
                        <li>基于理性决策、经验反馈、科学推理，并追求效率和经济性。</li>
                        <li><em>组织和团队本身也是信息系统，复杂性管理同样适用于它们。</em></li>
                    </ul>
                </li>
                <li><strong>数字化颠覆性组织：</strong>
                    <ul>
                        <li>这些组织通常<strong>由工程主导</strong>，软件是核心业务而非成本中心。</li>
                        <li>采用<strong>BAPO模型</strong>（业务-架构-流程-组织），而非传统的OBAP模型，即组织结构服务于业务目标。</li>
                        <li><em>通过<strong>解耦组织内部团队</strong>，可实现高可伸缩性和效率。</em></li>
                    </ul>
                </li>
                <li><strong>结果与机制：</strong>
                    <ul>
                        <li><strong>结果比机制更重要。</strong>例如，持续交付定义了“始终处于可发布状态”的期望结果，而DevOps则是一系列实现该结果的实践。</li>
                        <li><em>科学方法（描述、假设、预测、实验）是<strong>最持久和通用的原则</strong>。</em></li>
                    </ul>
                </li>
                <li class="ai-ml"><strong>持久且普遍适用：</strong>
                    <ul>
                        <li><em>这些工程原则也适用于<strong>机器学习（ML）</strong>。</em></li>
                        <li><strong>ML工作流</strong>（数据准备、训练、生产）本质上是<strong>迭代、反馈驱动、实验性和经验性</strong>的。</li>
                        <li>需优化ML流程的<strong>学习效率</strong>，加快迭代，清晰反馈。</li>
                        <li><strong>管理复杂性：</strong>对ML系统而言，这意味着对脚本、训练数据进行<strong>版本控制、模块化、内聚和关注点分离</strong>。</li>
                        <li><em>ML中的偏见问题，可理解为训练数据中“关注点分离不佳”的体现。</em></li>
                        <li><em>工程思维能帮助ML领域提出新的优化和质量问题，指导更好的ML系统生产。</em></li>
                    </ul>
                </li>
                <li><strong>总结：</strong>
                    <ul>
                        <li><em>本书的理念是指导你<strong>更有效地运用工具</strong>。</em></li>
                        <li>通过<strong>优化学习能力</strong>和<strong>管理复杂性</strong>，能显著提高构建<strong>更快更好软件</strong>的成功几率。</li>
                        <li><em>这些是<strong>真正软件工程学科的标志</strong>。</em></li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>

    <script>
        document.querySelectorAll('.accordion-header').forEach(button => {
            button.addEventListener('click', () => {
                const content = button.nextElementSibling;
                const arrow = button.querySelector('.arrow');

                // Toggle current accordion
                button.classList.toggle('active');
                content.classList.toggle('show');

                // Rotate arrow
                if (content.classList.contains('show')) {
                    arrow.innerHTML = '&#9660;'; // Down arrow
                } else {
                    arrow.innerHTML = '&#9658;'; // Right arrow
                }

                // Close all other top-level accordions
                document.querySelectorAll('.accordion-content.show').forEach(openContent => {
                    if (openContent !== content) {
                        openContent.classList.remove('show');
                        const header = openContent.previousElementSibling;
                        header.classList.remove('active');
                        header.querySelector('.arrow').innerHTML = '&#9658;'; // Reset arrow
                    }
                });

                // Ensure content height is correctly calculated for smooth animation
                if (content.classList.contains('show')) {
                    content.style.maxHeight = content.scrollHeight + "px";
                } else {
                    content.style.maxHeight = null;
                }
            });
        });

        // For nested accordions (if any, though not strictly used in this summary structure)
        document.querySelectorAll('.nested-accordion-header').forEach(button => {
            button.addEventListener('click', (event) => {
                event.stopPropagation(); // Prevent main accordion from toggling
                const content = button.nextElementSibling;
                const arrow = button.querySelector('.nested-arrow');

                button.classList.toggle('active');
                content.classList.toggle('show');

                if (content.classList.contains('show')) {
                    arrow.innerHTML = '&#9660;'; // Down arrow
                    content.style.maxHeight = content.scrollHeight + "px";
                } else {
                    arrow.innerHTML = '&#9658;'; // Right arrow
                    content.style.maxHeight = null;
                }
            });
        });
    </script>

<div class="attachments-panel" id="attachments-panel">
    <h3>原文</h3>
    <a href="book_modernse_files/book.html" target="_blank">源链接</a>
    <h3>附件</h3>
        <div class="attachment-item">
            <h4>中文PDF <span class="file-size">(19.2M)</span></h4>
            <a href="book_modernse_files/book.pdf" class="download-btn" download>下载</a>
        </div>
        <div class="attachment-item">
            <h4>中文epub <span class="file-size">(3.6M)</span></h4>
            <a href="book_modernse_files/book.epub" class="download-btn" download>下载</a>
        </div>
</div>
<button class="float-toggle" id="float-toggle" title="打开附件面板">◁</button>
<script>
// 浮动框展开/收起功能
document.addEventListener('DOMContentLoaded', function() {
    const panel = document.getElementById('attachments-panel');
    const toggleBtn = document.getElementById('float-toggle');
    
    if (!panel || !toggleBtn) return;
    
    // 切换面板显示状态
    function togglePanel() {
        panel.classList.toggle('expanded');
        // 更新按钮图标
        const isExpanded = panel.classList.contains('expanded');
        toggleBtn.textContent = isExpanded ? '▷' : '◁';
        toggleBtn.title = isExpanded ? '关闭附件面板' : '打开附件面板';
        
        // 动态调整按钮位置
        if (isExpanded) {
            // 等待面板展开动画完成后调整按钮位置
            setTimeout(() => {
                const panelWidth = panel.offsetWidth;
                toggleBtn.style.right = (panelWidth + 30) + 'px';
            }, 300);
        } else {
            toggleBtn.style.right = '10px';
        }
    }
    
    // 点击切换按钮
    toggleBtn.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        togglePanel();
    });
    
    // 点击页面其他地方时收起面板
    document.addEventListener('click', function(e) {
        const isClickOnPanel = panel.contains(e.target);
        const isClickOnToggle = toggleBtn.contains(e.target);
        
        if (!isClickOnPanel && !isClickOnToggle) {
            panel.classList.remove('expanded');
            toggleBtn.textContent = '◁';
            toggleBtn.title = '打开附件面板';
            toggleBtn.style.right = '10px'; // 重置按钮位置
        }
    });
    
    // ESC键关闭面板
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && panel.classList.contains('expanded')) {
            panel.classList.remove('expanded');
            toggleBtn.textContent = '◁';
            toggleBtn.title = '打开附件面板';
            toggleBtn.style.right = '10px'; // 重置按钮位置
        }
    });
});
</script>
</body>
</html>