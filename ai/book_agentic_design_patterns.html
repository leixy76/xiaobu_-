<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>《智能体设计模式》核心摘要</title>
    <style>
        :root {
            --primary-color: #4a90e2;
            --secondary-color: #f4f8ff;
            --text-color: #333;
            --light-text-color: #555;
            --border-color: #e0e0e0;
            --highlight-bg: #e8f0fe;
            --takeaway-bg: #fffbe6;
            --bg-color: #f9f9f9;
            --card-bg: #ffffff;
            --shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "Helvetica Neue", Helvetica, Arial, sans-serif;
            line-height: 1.7;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background-color: var(--card-bg);
            border-radius: 12px;
            box-shadow: var(--shadow);
            overflow: hidden;
            animation: fadeIn 0.8s ease-out;
        }

        header {
            background-color: var(--primary-color);
            color: white;
            padding: 30px 40px;
            text-align: center;
        }

        header h1 {
            margin: 0;
            font-size: 2.2em;
            font-weight: 600;
        }

        header p {
            margin: 10px 0 0;
            font-size: 1.1em;
            opacity: 0.9;
        }

        main {
            padding: 30px 40px;
        }

        section {
            margin-bottom: 40px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 30px;
        }
        section:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }

        h2 {
            font-size: 1.8em;
            color: var(--primary-color);
            border-bottom: 2px solid var(--secondary-color);
            padding-bottom: 10px;
            margin-top: 0;
        }

        .highlight {
            background-color: var(--highlight-bg);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid var(--primary-color);
            margin: 20px 0;
        }
        .highlight strong {
            color: var(--primary-color);
        }

        .takeaway {
            background-color: var(--takeaway-bg);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #ffc107;
        }
        .takeaway strong {
            color: #b38600;
        }

        .patterns-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        details {
            background-color: var(--secondary-color);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            transition: all 0.3s ease;
        }
        details[open] {
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
        }

        summary {
            font-size: 1.1em;
            font-weight: 600;
            padding: 15px;
            cursor: pointer;
            list-style: none;
            display: flex;
            align-items: center;
            gap: 10px;
            color: var(--primary-color);
        }

        summary::-webkit-details-marker { display: none; }

        summary::before {
            content: '＋';
            display: inline-block;
            font-size: 1.2em;
            transition: transform 0.3s ease;
            color: var(--primary-color);
        }

        details[open] summary::before {
            transform: rotate(45deg);
        }

        .details-content {
            padding: 0 20px 20px 20px;
            color: var(--light-text-color);
        }

        .details-content p {
            margin: 10px 0;
        }

        .details-content strong {
            color: var(--text-color);
        }

        ul {
            list-style-type: none;
            padding-left: 0;
        }
        ul li {
            background-color: #fff;
            padding: 10px 15px;
            border-radius: 6px;
            margin-bottom: 10px;
            border: 1px solid var(--border-color);
        }

        footer {
            text-align: center;
            padding: 20px;
            color: #888;
            font-size: 0.9em;
            background-color: var(--secondary-color);
        }
        
        @media (max-width: 600px) {
            body { padding: 10px; }
            main, header { padding: 20px; }
            h1 { font-size: 1.8em; }
            h2 { font-size: 1.5em; }
            .patterns-grid {
                grid-template-columns: 1fr;
            }
        }
    /* 主容器布局调整 - 移除flex布局以保持原始排版 */

.attachments-panel {
    width: 250px;
    background: #fff;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    height: fit-content;
    position: sticky;
    top: 20px;
    flex-shrink: 0;
    z-index: 1000;
    border: 1px solid #e0e0e0;
}
.attachments-panel h3 {
    color: #004085;
    margin-top: 0;
    margin-bottom: 15px;
    text-align: center;
    border-bottom: 2px solid #004085;
    padding-bottom: 10px;
}
.attachment-item {
    background-color: #f8f9fa;
    border: 1px solid #ced4da;
    border-radius: 5px;
    padding: 15px;
    margin-bottom: 15px;
    transition: all 0.3s ease;
}
.attachment-item:hover {
    background-color: #e9ecef;
    border-color: #004085;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}
.attachment-item h4 {
    margin: 0 0 8px 0;
    color: #004085;
    font-size: 14px;
}
.attachment-item p {
    margin: 0 0 10px 0;
    font-size: 12px;
    color: #6c757d;
    line-height: 1.4;
}
.download-btn {
    display: inline-block;
    background-color: #28a745;
    color: white;
    text-decoration: none;
    padding: 8px 16px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: bold;
    transition: background-color 0.3s ease;
    width: 100%;
    text-align: center;
    box-sizing: border-box;
}
.download-btn:hover {
    background-color: #218838;
    text-decoration: none;
    color: white;
}
.download-btn:before {
    content: "▼ ";
    margin-right: 5px;
}

/* 可折叠浮动框样式 */
.attachments-panel {
    position: fixed;
    top: 10px;
    right: 10px;
    width: auto; /* 自适应宽度 */
    min-width: 250px; /* 最小宽度 */
    max-width: calc(100vw - 60px); /* 最大宽度，留出边距 */
    max-height: calc(100vh - 80px); /* 留出更多空间避免滚动条 */
    overflow-y: auto;
    overflow-x: hidden; /* 隐藏横向滚动条 */
    z-index: 9999;
    box-shadow: 0 8px 24px rgba(0,0,0,0.25);
    border: 2px solid #004085;
    transform: translateX(100%); /* 默认完全隐藏 */
    transition: transform 0.3s ease;
    /* 自定义滚动条样式 */
    scrollbar-width: thin;
    scrollbar-color: #004085 #f0f0f0;
}

/* WebKit浏览器滚动条样式 */
.attachments-panel::-webkit-scrollbar {
    width: 6px;
}

.attachments-panel::-webkit-scrollbar-track {
    background: #f0f0f0;
    border-radius: 3px;
}

.attachments-panel::-webkit-scrollbar-thumb {
    background: #004085;
    border-radius: 3px;
}

.attachments-panel::-webkit-scrollbar-thumb:hover {
    background: #0056b3;
}

/* 展开时显示 */
.attachments-panel.expanded {
    transform: translateX(0);
}

/* 移除container的margin-right设置，保持原始布局 */

.attachment-item {
    width: 250px;
    margin-right: 0;
    display: block;
    margin-bottom: 12px;
    white-space: nowrap; /* 防止文本换行导致宽度过大 */
}

.attachment-item h4 {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis; /* 长文本显示省略号 */
    max-width: 100%;
}

.attachments-panel h3 {
    font-size: 16px;
    margin-bottom: 12px;
    white-space: nowrap; /* 标题不换行 */
}

.attachments-panel a {
    white-space: nowrap; /* 链接文本不换行 */
    overflow: hidden;
    text-overflow: ellipsis;
    display: inline-block;
    max-width: 100%;
}

/* 浮动切换按钮 */
.float-toggle {
    position: fixed;
    top: 10px;
    right: 10px;
    width: 50px;
    height: 50px;
    background: #004085;
    color: white;
    border: none;
    border-radius: 50%;
    font-size: 20px;
    cursor: pointer;
    z-index: 10000;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

.float-toggle:hover {
    background: #0056b3;
    transform: scale(1.1);
}

.float-toggle:active {
    transform: scale(0.95);
}

/* 当面板展开时，按钮位置动态调整 */
.attachments-panel.expanded ~ .float-toggle {
    right: 20px; /* 保持在面板左侧的固定位置 */
    opacity: 0.7; /* 展开时降低透明度，避免遮挡 */
}
    </style>
</head>
<body>

    <div class="container">
        <header>
            <h1>《智能体设计模式》核心摘要</h1>
            <p>一本关于构建智能、自主且可靠的AI智能体的架构蓝图。</p>
        </header>

        <main>
            <section id="core-concepts">
                <h2>核心理念：什么是智能体系统？</h2>
                <div class="highlight">
                    <p><strong>定义：</strong> 智能体系统 (Agentic System) 是一个计算实体，它能<strong>感知环境</strong>，基于目标<strong>做出决策</strong>，并<strong>自主执行动作</strong>以达成目标。它不仅仅是遵循死板指令的程序，而是具备一定灵活性和主动性的智能实体。</p>
                </div>
                
                <h3>智能体的关键特征</h3>
                <ul>
                    <li><strong>自主性 (Autonomy):</strong> 无需持续的人类监督即可行动。</li>
                    <li><strong>主动性 (Proactiveness):</strong> 主动发起行动以实现目标。</li>
                    <li><strong>反应性 (Reactiveness):</strong> 能有效响应环境变化。</li>
                    <li><strong>目标导向 (Goal-oriented):</strong> 始终围绕特定目标工作。</li>
                    <li><strong>工具使用 (Tool Use):</strong> 能够调用外部API、数据库或服务。</li>
                    <li><strong>记忆 (Memory):</strong> 在多次交互中保留和利用信息。</li>
                    <li><strong>沟通 (Communication):</strong> 与用户、其他系统或其他智能体进行交互。</li>
                </ul>

                <h3>智能体复杂度的四个层次</h3>
                <ol>
                    <li><strong>Level 0: 核心推理引擎</strong> - 纯粹的LLM，仅依赖预训练知识，无外部交互。</li>
                    <li><strong>Level 1: 连接的问题解决者</strong> - 能够使用外部工具（如搜索、RAG）来获取实时信息。</li>
                    <li><strong>Level 2: 战略性问题解决者</strong> - 能够进行规划、主动辅助和自我改进，核心是<strong>上下文工程 (Context Engineering)</strong>。</li>
                    <li><strong>Level 3: 协作式多智能体系统</strong> - 由多个专业智能体组成的团队，协同解决复杂问题，模仿人类组织。</li>
                </ol>
            </section>

            <section id="design-patterns">
                <h2>21个核心智能体设计模式</h2>
                <p>本书的核心是这21个经过实战检验的设计模式，它们是构建强大智能体系统的基础构建块。</p>
                <div class="patterns-grid">
                    
                    <details>
                        <summary>1. 提示链 (Prompt Chaining)</summary>
                        <div class="details-content">
                            <p><strong>是什么：</strong>将复杂任务分解为一系列更小的、连续的子任务。前一个任务的输出成为后一个任务的输入。</p>
                            <p><strong>为什么：</strong>提高可靠性和可控性，降低单个提示的认知负荷，便于调试。</p>
                            <div class="takeaway"><strong>经验法则：</strong>当单个提示无法处理多步骤或多约束任务时使用。</div>
                        </div>
                    </details>
                    
                    <details>
                        <summary>2. 路由 (Routing)</summary>
                        <div class="details-content">
                            <p><strong>是什么：</strong>引入条件逻辑，让智能体根据输入或当前状态，动态选择下一步要执行的工具、函数或子智能体。</p>
                            <p><strong>为什么：</strong>实现灵活、上下文感知的行为，而不是固定的线性流程。</p>
                            <div class="takeaway"><strong>经验法则：</strong>当需要根据用户意图（如销售、支持、查询）将请求分派到不同工作流时使用。</div>
                        </div>
                    </details>

                    <details>
                        <summary>3. 并行化 (Parallelization)</summary>
                        <div class="details-content">
                            <p><strong>是什么：</strong>同时执行多个独立的任务或工具调用，而不是按顺序执行。</p>
                            <p><strong>为什么：</strong>显著减少总执行时间，尤其是在处理多个独立的API调用或数据源时。</p>
                            <div class="takeaway"><strong>经验法则：</strong>当工作流包含多个互不依赖的子任务时（如同时查询航班和酒店）。</div>
                        </div>
                    </details>
                    
                    <details>
                        <summary>4. 反思 (Reflection)</summary>
                        <div class="details-content">
                            <p><strong>是什么：</strong>智能体评估自己的输出或工作流程，并利用该评估进行自我纠正或改进。</p>
                            <p><strong>为什么：</strong>提高输出质量、准确性和对复杂约束的遵守。强大的实现是“生产者-批评家”模型。</p>
                            <div class="takeaway"><strong>经验法则：</strong>当输出质量比速度和成本更重要时（如代码生成、长文写作）。</div>
                        </div>
                    </details>

                    <details>
                        <summary>5. 工具使用 (Tool Use)</summary>
                        <div class="details-content">
                            <p><strong>是什么：</strong>让智能体与外部API、数据库或服务交互，以获取实时信息或执行操作。</p>
                            <p><strong>为什么：</strong>突破LLM静态训练数据的限制，使其能够与真实世界互动。</p>
                            <div class="takeaway"><strong>经验法则：</strong>当需要实时数据（天气、股价）或与外部系统交互（发邮件、下单）时使用。</div>
                        </div>
                    </details>

                    <details>
                        <summary>6. 规划 (Planning)</summary>
                        <div class="details-content">
                            <p><strong>是什么：</strong>智能体将一个高层目标分解为一系列可执行的步骤或子目标。</p>
                            <p><strong>为什么：</strong>处理需要多步骤、有依赖关系的复杂任务，将“做什么”转化为“怎么做”。</p>
                            <div class="takeaway"><strong>经验法则：</strong>用于自动化多步骤流程，如生成研究报告或项目管理。</div>
                        </div>
                    </details>
                    
                    <details>
                        <summary>7. 多智能体协作 (Multi-Agent)</summary>
                        <div class="details-content">
                            <p><strong>是什么：</strong>将系统设计为由多个独立的、专业的智能体组成的团队，共同协作完成一个目标。</p>
                            <p><strong>为什么：</strong>利用专业分工解决多领域、多阶段的复杂问题，提高模块化和可扩展性。</p>
                            <div class="takeaway"><strong>经验法则：</strong>当任务需要多种不同技能或可以并行处理时（如软件开发团队）。</div>
                        </div>
                    </details>
                    
                    <details>
                        <summary>8. 记忆管理 (Memory)</summary>
                        <div class="details-content">
                            <p><strong>是什么：</strong>为智能体提供保留和利用过去信息的能力，分为短期（上下文窗口）和长期（外部存储）记忆。</p>
                            <p><strong>为什么：</strong>维持对话连贯性，实现个性化，并从过去的经验中学习。</p>
                            <div class="takeaway"><strong>经验法则：</strong>所有需要跨越多轮对话或会话的智能体都必须使用。</div>
                        </div>
                    </details>

                    <details>
                        <summary>9. 学习与适应 (Learning)</summary>
                        <div class="details-content">
                            <p><strong>是什么：</strong>智能体根据新的经验或数据改变其行为、知识或策略，如通过强化学习或自我代码修改（SICA）。</p>
                            <p><strong>为什么：</strong>使智能体能够随着时间的推移而进化和改进，适应不断变化的环境。</p>
                            <div class="takeaway"><strong>经验法则：</strong>用于需要在动态、不确定环境中自主运行并持续优化的智能体。</div>
                        </div>
                    </details>
                    
                    <details>
                        <summary>10. 模型上下文协议 (MCP)</summary>
                        <div class="details-content">
                            <p><strong>是什么：</strong>一个开放标准，用于规范LLM与外部工具、数据源之间的发现和通信。</p>
                            <p><strong>为什么：</strong>促进不同LLM和工具之间的互操作性，构建可复用、可组合的智能体生态系统。</p>
                            <div class="takeaway"><strong>经验法则：</strong>在需要构建可扩展、跨平台的企业级智能体系统时使用。</div>
                        </div>
                    </details>
                    
                    <details>
                        <summary>11. 目标设定与监控</summary>
                        <div class="details-content">
                            <p><strong>是什么：</strong>为智能体设定明确、可衡量的目标，并持续监控其实现目标的进度。</p>
                            <p><strong>为什么：</strong>确保智能体行为有目的性，并能在偏离目标时进行调整，实现可靠的自主操作。</p>
                            <div class="takeaway"><strong>经验法则：</strong>用于需要自主执行多步骤任务并确保最终成功的关键应用。</div>
                        </div>
                    </details>

                    <details>
                        <summary>12. 异常处理与恢复</summary>
                        <div class="details-content">
                            <p><strong>是什么：</strong>设计机制来预见、检测和处理操作失败（如工具错误、API超时），并从中恢复。</p>
                            <p><strong>为什么：</strong>构建在现实世界中可靠、有韧性的智能体，而不是在遇到意外时就崩溃的脆弱系统。</p>
                            <div class="takeaway"><strong>经验法则：</strong>所有生产环境中的智能体都必须具备。</div>
                        </div>
                    </details>

                    <details>
                        <summary>13. 人类在环 (Human-in-the-Loop)</summary>
                        <div class="details-content">
                            <p><strong>是什么：</strong>在AI工作流中战略性地整合人类的判断、监督和反馈。</p>
                            <p><strong>为什么：</strong>确保安全性、道德合规性，并处理AI无法可靠处理的模糊或高风险任务。</p>
                            <div class="takeaway"><strong>经验法则：</strong>在医疗、金融、法律等高风险领域，或在内容审核等需要细微判断的场景中使用。</div>
                        </div>
                    </details>

                    <details>
                        <summary>14. 知识检索 (RAG)</summary>
                        <div class="details-content">
                            <p><strong>是什么：</strong>在生成响应之前，从外部知识库（如文档、数据库）中检索相关信息，并将其作为上下文提供给LLM。</p>
                            <p><strong>为什么：</strong>提供最新、准确、可验证的答案，减少“幻觉”，并利用专有知识。</p>
                            <div class="takeaway"><strong>经验法则：</strong>当需要基于特定、最新或内部文档回答问题时，这是标准做法。</div>
                        </div>
                    </details>

                    <details>
                        <summary>15. 智能体间通信 (A2A)</summary>
                        <div class="details-content">
                            <p><strong>是什么：</strong>一个开放的、基于HTTP的协议，使不同框架构建的AI智能体能够相互通信和协作。</p>
                            <p><strong>为什么：</strong>实现真正的多智能体生态系统，其中专业智能体可以相互委托任务。</p>
                            <div class="takeaway"><strong>经验法则：</strong>当需要协调使用不同技术栈构建的多个智能体时。</div>
                        </div>
                    </details>
                    
                    <details>
                        <summary>16. 资源感知优化</summary>
                        <div class="details-content">
                            <p><strong>是什么：</strong>智能体根据任务的复杂性和资源约束（如成本、延迟），动态选择使用哪个模型或工具。</p>
                            <p><strong>为什么：</strong>在响应质量、成本和速度之间实现最佳平衡。</p>
                            <div class="takeaway"><strong>经验法则：</strong>在有严格预算或延迟要求的生产应用中使用。</div>
                        </div>
                    </details>

                    <details>
                        <summary>17. 推理技术</summary>
                        <div class="details-content">
                            <p><strong>是什么：</strong>使用如思维链 (CoT)、思维树 (ToT) 等技术，引导LLM进行多步骤的、明确的逻辑推理。</p>
                            <p><strong>为什么：</strong>显著提高在复杂逻辑、数学和规划任务上的表现，并使推理过程透明化。</p>
                            <div class="takeaway"><strong>经验法则：</strong>当问题无法通过简单直觉回答，需要分解和逻辑推导时使用。</div>
                        </div>
                    </details>

                    <details>
                        <summary>18. 护栏/安全模式</summary>
                        <div class="details-content">
                            <p><strong>是什么：</strong>实施一系列规则和过滤器来确保智能体的行为安全、合乎道德且符合预期。</p>
                            <p><strong>为什么：</strong>防止产生有害、有偏见或不相关的输出，维护用户信任和系统完整性。</p>
                            <div class="takeaway"><strong>经验法则：</strong>所有面向用户的、自主的智能体都必须实施。</div>
                        </div>
                    </details>
                    
                    <details>
                        <summary>19. 评估与监控</summary>
                        <div class="details-content">
                            <p><strong>是什么：</strong>系统地评估智能体的性能，监控其实现目标的进度，并检测操作异常。</p>
                            <p><strong>为什么：</strong>确保智能体在部署后持续满足性能和可靠性要求，并为迭代改进提供数据支持。</p>
                            <div class="takeaway"><strong>经验法则：</strong>用于生产系统，以跟踪准确性、延迟、成本和用户满意度。</div>
                        </div>
                    </details>
                    
                    <details>
                        <summary>20. 优先级排序 (Prioritization)</summary>
                        <div class="details-content">
                            <p><strong>是什么：</strong>让智能体根据重要性、紧迫性、依赖关系等标准对任务或目标进行排序。</p>
                            <p><strong>为什么：</strong>在资源有限的情况下，确保智能体首先处理最关键的任务，提高效率。</p>
                            <div class="takeaway"><strong>经验法则：</strong>在智能体需要同时处理多个（可能冲突的）任务时使用。</div>
                        </div>
                    </details>

                    <details>
                        <summary>21. 探索与发现</summary>
                        <div class="details-content">
                            <p><strong>是什么：</strong>让智能体主动寻求新信息，发现新可能性，或识别环境中的“未知之未知”。</p>
                            <p><strong>为什么：</strong>用于开放式、复杂或快速变化的领域，其中静态知识不足以解决问题。</p>
                            <div class="takeaway"><strong>经验法则：</strong>在科学研究、市场趋势发现或创新策略生成等任务中使用。</div>
                        </div>
                    </details>

                </div>
            </section>
            
            <section id="future-outlook">
                <h2>未来展望：智能体的五大假说</h2>
                <div class="highlight">
                    <p>本书不仅关注当下，还对智能体技术的未来发展提出了五大前瞻性假说，揭示了其巨大的潜力。</p>
                </div>
                <ul>
                    <li><strong>假说1: 通才智能体的出现</strong> - AI将从狭隘的专家发展为能处理复杂、长期、模糊目标的高可靠性通才。</li>
                    <li><strong>假说2: 深度个性化与主动目标发现</strong> - 智能体将成为主动的合作伙伴，不仅执行命令，还能预测并帮助用户发现他们尚未明确表达的潜在目标。</li>
                    <li><strong>假说3: 具身化与物理世界交互</strong> - AI将与机器人技术结合，从数字世界走向物理世界，执行修理、维护等实体任务。</li>
                    <li><strong>假说4: 智能体驱动的经济</strong> - 高度自主的智能体将成为独立的经济实体，创建全新的市场和商业模式。</li>
                    <li><strong>假说5: 目标驱动的、可变形的多智能体系统</strong> - 用户只需声明最终目标，系统就能自主创建、调整和重构其智能体团队，以最有效的方式实现目标。</li>
                </ul>
            </section>
            
            <section id="frameworks">
                <h2>附录精选：主流框架与工具</h2>
                <p>本书的实战部分使用了多个主流的智能体开发框架，了解它们有助于您选择合适的工具。</p>
                <ul>
                    <li><strong>LangChain & LangGraph:</strong> 提供了构建智能体工作流的基础组件。LangChain擅长线性的、无环的工作流（DAGs），而LangGraph则支持更复杂的、带循环的状态机，是构建高级智能体的强大工具。</li>
                    <li><strong>Google ADK (Agent Development Kit):</strong> 一个更高级、结构化的框架，专为构建和部署由多个交互AI智能体组成的生产级应用而设计，提供了更全面的多智能体交互模式。</li>
                    <li><strong>CrewAI:</strong> 一个专注于多智能体协作的框架，强调通过定义具有特定角色、目标和背景故事的智能体来模拟人类团队合作。</li>
                    <li><strong>命令行智能体 (CLI Agents):</strong> 新一波的AI工具正将智能体能力带入开发者的命令行，如Claude CLI、Gemini CLI、Aider等，它们能理解代码库，并执行大规模重构、测试和文档生成等复杂任务。</li>
                </ul>
            </section>
        </main>
        
        <footer>
            <p>这份摘要旨在以超轻认知负荷的方式，为您呈现《智能体设计模式》的全貌。&copy; 2024</p>
        </footer>
    </div>
<script>
    // A simple script to add a class to details when they open, for potential extra styling.
    // The core functionality works without JS.
    document.querySelectorAll('details').forEach(detail => {
        detail.addEventListener('toggle', event => {
            if (detail.open) {
                detail.classList.add('is-open');
            } else {
                detail.classList.remove('is-open');
            }
        });
    });
</script>

<div class="attachments-panel" id="attachments-panel">
    <h3>原文</h3>
    <a href="book_agentic_design_patterns_files/book.html" target="_blank">中文cc译本</a>
    <h3>相关链接</h3>
        <a href="https://docs.google.com/document/d/1rsaK53T3Lg5KoGwvf8ukOUvbELRtH-V0LnOIFDxBryE/preview?tab=t.0#heading=h.pxcur8v2qagu" target="_blank">作者原书</a><br>
    <h3>附件</h3>
        <div class="attachment-item">
            <h4>中文Docx <span class="file-size">(8.9M)</span></h4>
            <a href="book_agentic_design_patterns_files/book.docx" class="download-btn" download>下载</a>
        </div>
        <div class="attachment-item">
            <h4>中文epub <span class="file-size">(9.2M)</span></h4>
            <a href="book_agentic_design_patterns_files/book.epub" class="download-btn" download>下载</a>
        </div>
</div>
<button class="float-toggle" id="float-toggle" title="打开附件面板">◁</button>
<script>
// 浮动框展开/收起功能
document.addEventListener('DOMContentLoaded', function() {
    const panel = document.getElementById('attachments-panel');
    const toggleBtn = document.getElementById('float-toggle');
    
    if (!panel || !toggleBtn) return;
    
    // 切换面板显示状态
    function togglePanel() {
        panel.classList.toggle('expanded');
        // 更新按钮图标
        const isExpanded = panel.classList.contains('expanded');
        toggleBtn.textContent = isExpanded ? '▷' : '◁';
        toggleBtn.title = isExpanded ? '关闭附件面板' : '打开附件面板';
        
        // 动态调整按钮位置
        if (isExpanded) {
            // 等待面板展开动画完成后调整按钮位置
            setTimeout(() => {
                const panelWidth = panel.offsetWidth;
                toggleBtn.style.right = (panelWidth + 30) + 'px';
            }, 300);
        } else {
            toggleBtn.style.right = '10px';
        }
    }
    
    // 点击切换按钮
    toggleBtn.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        togglePanel();
    });
    
    // 点击页面其他地方时收起面板
    document.addEventListener('click', function(e) {
        const isClickOnPanel = panel.contains(e.target);
        const isClickOnToggle = toggleBtn.contains(e.target);
        
        if (!isClickOnPanel && !isClickOnToggle) {
            panel.classList.remove('expanded');
            toggleBtn.textContent = '◁';
            toggleBtn.title = '打开附件面板';
            toggleBtn.style.right = '10px'; // 重置按钮位置
        }
    });
    
    // ESC键关闭面板
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && panel.classList.contains('expanded')) {
            panel.classList.remove('expanded');
            toggleBtn.textContent = '◁';
            toggleBtn.title = '打开附件面板';
            toggleBtn.style.right = '10px'; // 重置按钮位置
        }
    });
});
</script>
</body>
</html>