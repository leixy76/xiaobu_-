<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>《Programming TypeScript》核心摘要</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
            line-height: 1.7;
            background-color: #ffffff;
            color: #333;
            padding: 20px;
            max-width: 900px;
            margin: 0 auto;
        }

        .container {
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            padding: 25px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }

        h1, h2 {
            border-bottom: 2px solid #f0f0f0;
            padding-bottom: 10px;
            color: #2c3e50;
        }

        h1 {
            font-size: 2.2em;
            text-align: center;
        }

        .subtitle {
            text-align: center;
            color: #7f8c8d;
            margin-top: -15px;
            font-size: 1.1em;
        }

        details {
            background-color: #f9f9f9;
            border: 1px solid #eee;
            border-radius: 8px;
            margin-bottom: 15px;
            padding: 15px;
            transition: background-color 0.3s ease;
        }

        details[open] {
            background-color: #f0f8ff;
        }

        summary {
            font-weight: bold;
            font-size: 1.3em;
            cursor: pointer;
            color: #34495e;
            list-style: none; /* 移除默认箭头 */
        }
        
        summary::-webkit-details-marker { /* 兼容 Chrome/Safari */
          display: none;
        }

        summary::before {
            content: '▶';
            margin-right: 10px;
            display: inline-block;
            transition: transform 0.2s;
            font-size: 0.9em;
        }

        details[open] > summary::before {
            transform: rotate(90deg);
        }

        .content {
            padding-top: 15px;
            border-top: 1px solid #e0e0e0;
            margin-top: 10px;
        }

        h3 {
            color: #2980b9;
            font-size: 1.2em;
            margin-top: 20px;
        }
        
        h4 {
            color: #34495e;
            font-style: italic;
            border-left: 3px solid #3498db;
            padding-left: 10px;
        }

        code {
            background-color: #ecf0f1;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
            font-size: 0.9em;
        }

        pre {
            background-color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            border: 1px solid #bdc3c7;
        }
        
        pre code {
            padding: 0;
            background: none;
            border: none;
        }
        
        ul {
            padding-left: 20px;
        }
        
        li {
            margin-bottom: 10px;
        }

        .highlight {
            padding: 2px 5px;
            border-radius: 3px;
        }

        .hl-point { /* 作者观点/哲学 */
            background-color: rgba(41, 128, 185, 0.1);
        }

        .hl-fact { /* 事实/定义 */
            background-color: rgba(241, 196, 15, 0.2);
        }
        
        .hl-term { /* 专业术语 */
            background-color: rgba(26, 188, 156, 0.15);
            font-weight: bold;
        }
    /* 主容器布局调整 - 移除flex布局以保持原始排版 */

.attachments-panel {
    width: 250px;
    background: #fff;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    height: fit-content;
    position: sticky;
    top: 20px;
    flex-shrink: 0;
    z-index: 1000;
    border: 1px solid #e0e0e0;
}
.attachments-panel h3 {
    color: #004085;
    margin-top: 0;
    margin-bottom: 15px;
    text-align: center;
    border-bottom: 2px solid #004085;
    padding-bottom: 10px;
}
.attachment-item {
    background-color: #f8f9fa;
    border: 1px solid #ced4da;
    border-radius: 5px;
    padding: 15px;
    margin-bottom: 15px;
    transition: all 0.3s ease;
}
.attachment-item:hover {
    background-color: #e9ecef;
    border-color: #004085;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}
.attachment-item h4 {
    margin: 0 0 8px 0;
    color: #004085;
    font-size: 14px;
}
.attachment-item p {
    margin: 0 0 10px 0;
    font-size: 12px;
    color: #6c757d;
    line-height: 1.4;
}
.download-btn {
    display: inline-block;
    background-color: #28a745;
    color: white;
    text-decoration: none;
    padding: 8px 16px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: bold;
    transition: background-color 0.3s ease;
    width: 100%;
    text-align: center;
    box-sizing: border-box;
}
.download-btn:hover {
    background-color: #218838;
    text-decoration: none;
    color: white;
}
.download-btn:before {
    content: "▼ ";
    margin-right: 5px;
}

/* 可折叠浮动框样式 */
.attachments-panel {
    position: fixed;
    top: 10px;
    right: 10px;
    width: auto; /* 自适应宽度 */
    min-width: 250px; /* 最小宽度 */
    max-width: calc(100vw - 60px); /* 最大宽度，留出边距 */
    max-height: calc(100vh - 80px); /* 留出更多空间避免滚动条 */
    overflow-y: auto;
    overflow-x: hidden; /* 隐藏横向滚动条 */
    z-index: 9999;
    box-shadow: 0 8px 24px rgba(0,0,0,0.25);
    border: 2px solid #004085;
    transform: translateX(100%); /* 默认完全隐藏 */
    transition: transform 0.3s ease;
    /* 自定义滚动条样式 */
    scrollbar-width: thin;
    scrollbar-color: #004085 #f0f0f0;
}

/* WebKit浏览器滚动条样式 */
.attachments-panel::-webkit-scrollbar {
    width: 6px;
}

.attachments-panel::-webkit-scrollbar-track {
    background: #f0f0f0;
    border-radius: 3px;
}

.attachments-panel::-webkit-scrollbar-thumb {
    background: #004085;
    border-radius: 3px;
}

.attachments-panel::-webkit-scrollbar-thumb:hover {
    background: #0056b3;
}

/* 展开时显示 */
.attachments-panel.expanded {
    transform: translateX(0);
}

/* 移除container的margin-right设置，保持原始布局 */

.attachment-item {
    width: 250px;
    margin-right: 0;
    display: block;
    margin-bottom: 12px;
    white-space: nowrap; /* 防止文本换行导致宽度过大 */
}

.attachment-item h4 {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis; /* 长文本显示省略号 */
    max-width: 100%;
}

.attachments-panel h3 {
    font-size: 16px;
    margin-bottom: 12px;
    white-space: nowrap; /* 标题不换行 */
}

.attachments-panel a {
    white-space: nowrap; /* 链接文本不换行 */
    overflow: hidden;
    text-overflow: ellipsis;
    display: inline-block;
    max-width: 100%;
}

/* 浮动切换按钮 */
.float-toggle {
    position: fixed;
    top: 10px;
    right: 10px;
    width: 50px;
    height: 50px;
    background: #004085;
    color: white;
    border: none;
    border-radius: 50%;
    font-size: 20px;
    cursor: pointer;
    z-index: 10000;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

.float-toggle:hover {
    background: #0056b3;
    transform: scale(1.1);
}

.float-toggle:active {
    transform: scale(0.95);
}

/* 当面板展开时，按钮位置动态调整 */
.attachments-panel.expanded ~ .float-toggle {
    right: 20px; /* 保持在面板左侧的固定位置 */
    opacity: 0.7; /* 展开时降低透明度，避免遮挡 */
}
    </style>
</head>
<body>

    <div class="container">
        <h1>《Programming TypeScript》核心摘要</h1>
        <p class="subtitle">作者: Boris Cherny | 让你的 JavaScript 应用规模化</p>
        
        <details>
            <summary>关于作者：Boris Cherny</summary>
            <div class="content">
                <p>Boris Cherny 是一位杰出的工程和产品领导者，他的职业生涯横跨了大型社交媒体平台和前沿的人工智能大模型公司。他的经历充分展示了他在软件工程、产品战略以及对开发者社区（尤其是 TypeScript 社区）的深远影响。</p>
                
                <h4>职业经历摘要</h4>
                <ul>
                     <li><strong>Anthropic</strong> (2023年4月 - 至今):
                        <ul>
                            <li><em>主任提示工程师 (Staff Prompt Engineer)</em>: 作为 <strong>Claude Code 的创造者</strong>，他领导开发了一款革命性的“智能体编码AI”(Agentic Coding AI)。该产品最初是一个为解决内部需求的“意外”项目，但迅速在公司内部普及，并成为 Anthropic 增长最快的产品之一。</li>
                            <li><strong>伟大事迹</strong>: 他将 Claude Code 从一个个人原型（最初用于自动化笔记和音乐播放）发展成为一个强大的编程工具。关键的突破在于赋予模型使用基础工具（如 Bash 命令行）的能力，这让模型“自发地”开始进行复杂的编码任务。在他的推动下，Anthropic 的技术人员入职时间从几周缩短到几天，因为新员工可以直接向 Claude Code 提问来学习代码库。</li>
                            <li><strong>职业生涯关键事件</strong>: <span class="hl-fact">据 The Information 报道，在短暂离职并加入竞争对手 Anysphere（知名AI编程工具 Cursor 的开发者）仅仅两周后，他和同事 Cat Wu 被 Anthropic 成功返聘。这一事件凸显了他在公司编码AI战略中的核心地位和不可或缺的价值。</span></li>
                        </ul>
                    </li>
                    <li><strong>Meta (原 Facebook)</strong> (2016年 - 2023年):
                        <ul>
                            <li><em>产品主管 (Product Lead) & 工程经理 (Engineering Manager)</em>: 在创作者货币化和公共内容等领域担任领导角色，拥有近8年的丰富经验。</li>
                        </ul>
                    </li>
                    <li><strong>Twitter</strong> (2014年 - 2016年):
                        <ul>
                            <li><em>高级软件工程师 (Senior Software Engineer)</em>: 负责广告技术相关的前端工程。</li>
                        </ul>
                    </li>
                    <li><strong>O'Reilly Media</strong> (2018年 - 2019年):
                        <ul>
                            <li><em>作者 (Author)</em>: 撰写了本书《Programming TypeScript》，成为 TypeScript 社区的重要参考资料。</li>
                        </ul>
                    </li>
                </ul>
                
                <h4>产品与智能体编码哲学</h4>
                 <ul>
                    <li><strong>智能体编码 (Agentic Coding)</strong>: <span class="hl-point">他认为软件开发的未来正从“直接操作文本”转向“向智能体描述意图”。开发者提出需求，AI 智能体负责规划步骤、使用工具（如文件读写、搜索）并执行，从而完成任务。</span></li>
                    <li><strong>产品跟随模型</strong>: <span class="hl-point">他的核心产品理念是，在AI领域，产品设计不应过于复杂，而应构建一个“最小化的界面”来跟上模型能力的快速迭代。应该为“6个月后的模型能力”而设计产品，而不是仅仅满足于当下。</span></li>
                    <li><strong>先解决自己的问题 (Dogfooding)</strong>: <span class="hl-fact">Claude Code 的成功源于它首先解决了作者和 Anthropic 内部工程师的实际问题，其广泛的内部使用验证了产品的价值。</span></li>
                </ul>
                
                <h4>社区贡献与专业领域</h4>
                <ul>
                    <li><strong>旧金山 TypeScript Meetup</strong>: 作为组织者，积极推动 TypeScript 社区的发展和知识分享。</li>
                    <li><strong>专业兴趣</strong>: 对编程语言、代码合成、静态分析以及构建优秀的用户体验充满热情。</li>
                    <li><strong>个人博客</strong>: 在 <a href="http://borischerny.com/" target="_blank">borischerny.com</a> 上分享他的见解。</li>
                </ul>
                <p style="font-size: 0.8em; color: #7f8c8d;">(信息根据作者的 LinkedIn 个人资料及公开访谈整理)</p>
            </div>
        </details>

        <details>
            <summary>核心设计哲学与程序思维</summary>
            <div class="content">
                <p><span class="hl-point">本书的核心在于阐述 TypeScript 如何以一种<strong>极其务实</strong>的方式，帮助开发者构建更安全、更易于维护和扩展的 JavaScript 应用程序。</span></p>
                <h3>作者建议的设计哲学</h3>
                <ul>
                    <li><span class="hl-point"><strong>拥抱类型驱动开发 (Type-Driven Development)</strong>：先草拟类型签名，再填充实现细节。这迫使你从高层次思考程序结构，从而设计出更简洁、更可靠的系统。</span></li>
                    <li><span class="hl-point"><strong>实用性至上</strong>：TypeScript 的设计目标不是追求理论上的完美，而是解决 JavaScript 开发中的实际痛点，如恼人的 <code>cannot read property '...' of undefined</code> 错误。</span></li>
                    <li><span class="hl-point"><strong>缩短反馈循环</strong>：TypeScript 的最大优势之一是在你<strong>编写代码时</strong>就提供类型检查和错误提示，而不是等到运行时才发现问题。这极大地提高了开发效率和代码质量。</span></li>
                    <li><span class="hl-point"><strong>渐进式采用</strong>：TypeScript 被设计为可以与现有 JavaScript 代码库无缝协作，允许你逐步、按文件地迁移项目，而不是要求一次性重写。</span></li>
                </ul>
                <h3>推荐的编码风格与思维</h3>
                <ol>
                    <li><strong>尽可能让 TypeScript 推断类型</strong>：<span class="hl-point">避免不必要的显式类型注解。这能让代码更简洁，同时也能更好地暴露你可能没意识到的类型问题，而不是用显式类型“掩盖”它们。</span></li>
                    <li><strong>拥抱不可变性 (Immutability)</strong>：<span class="hl-point">多使用展开语法 (<code>...</code>) 创建新对象或数组，而不是直接修改它们。这使得状态变化更可预测，调试也更简单。</span></li>
                    <li><strong>编写可复用的泛型代码</strong>：<span class="hl-fact">多态（Polymorphism），特别是通过<span class="hl-term">泛型 (Generics)</span> 实现，是你最好的朋友。它能让你编写出既灵活又类型安全的代码。</span></li>
                    <li><strong>使用最新的 JavaScript 语法 (ESNext)</strong>：<span class="hl-point">这能让你的代码与标准保持一致，提高互操作性和可搜索性，并利用现代语言特性。</span></li>
                </ol>
            </div>
        </details>

        <details>
            <summary>第一、二章：TypeScript 概览、编译器与类型系统</summary>
            <div class="content">
                <h3>核心理念</h3>
                <ul>
                    <li><span class="hl-fact"><strong>什么是 TypeScript？</strong> 它是一个 JavaScript 的超集，为其添加了静态类型系统。</span></li>
                    <li><span class="hl-fact"><strong>编译过程</strong>：TS 代码 → TSC (TypeScript 编译器) → 1. 解析为 AST → 2. <span class="hl-term">类型检查</span> → 3. 编译为 JS 代码 → JS 运行时执行。</span></li>
                    <li><span class="hl-point"><strong>类型擦除 (Type Erasure)</strong>：类型信息只存在于编译时，用于类型检查。编译生成的 JavaScript 代码中<strong>不包含</strong>任何类型信息，因此 TypeScript 对运行时性能<strong>没有负面影响</strong>。</span></li>
                </ul>
                <h3>类型系统对比</h3>
                <ul>
                    <li><strong>JavaScript</strong>: <span class="hl-fact">动态类型、弱类型、运行时检查。</span></li>
                    <li><strong>TypeScript</strong>: <span class="hl-fact">静态类型、强类型（大部分情况）、编译时检查、<span class="hl-term">渐进类型 (Gradually Typed)</span> 和 <span class="hl-term">结构化类型 (Structurally Typed)</span>。</span></li>
                </ul>
                 <h4>结构化类型 (Structural Typing)</h4>
                <p><span class="hl-fact">也称为“鸭子类型”。TypeScript 不关心一个值的“名义”类型（例如它是由哪个类创建的），只关心它的“形状”（它有哪些属性和方法）。如果一个值的结构与期望的类型兼容，那么它就是类型兼容的。</span></p>
                <pre><code>class Cat { meow() { console.log('meow') } }
class Dog { meow() { console.log('bark as meow') } }

function pet(animal: Cat) {
  animal.meow();
}

pet(new Cat()); // OK
pet(new Dog()); // 也 OK, 因为 Dog 的“形状”满足 Cat 的要求</code></pre>
            </div>
        </details>
        
        <details>
            <summary>第三章：深入理解类型</summary>
            <div class="content">
                <p><span class="hl-fact">类型是“一组值以及你可以在这些值上执行的操作集合”。</span></p>
                <h3>关键类型</h3>
                <ul>
                    <li><code>any</code>: <span class="hl-point">类型系统的“教父”，应<strong>极力避免</strong>使用。它会关闭所有类型检查，让你回到不安全的 JavaScript 世界。</span></li>
                    <li><code>unknown</code>: <span class="hl-point">更安全的 <code>any</code>。它代表任何值，但在你通过类型收窄（如 <code>typeof</code> 检查）证明其具体类型之前，你不能对它执行任何操作。</span></li>
                    <li><strong>基础类型</strong>: <code>boolean</code>, <code>number</code>, <code>string</code>, <code>bigint</code>, <code>symbol</code>, <code>null</code>, <code>undefined</code>。</li>
                    <li><span class="hl-term"><strong>字面量类型 (Literal Types)</strong></span>: <span class="hl-fact">一个值本身也可以作为一种类型，例如 <code>type Status = 'success' | 'failure';</code>。这是 TS 强大表达能力的基础。</span></li>
                    <li><strong>对象与数组</strong>:
                        <ul>
                            <li><strong>对象</strong>: 使用 <code>{ key: type }</code> 描述其形状。<code>?</code> 表示可选属性，<code>readonly</code> 表示只读。</li>
                            <li><strong>数组</strong>: <code>number[]</code> 或 <code>Array&lt;number&gt;</code>。</li>
                            <li><span class="hl-term"><strong>元组 (Tuples)</strong></span>: <span class="hl-fact">固定长度和固定成员类型的数组，如 <code>[string, number]</code>。</span></li>
                        </ul>
                    </li>
                    <li><code>enum</code> (枚举): <span class="hl-point">作者建议<strong>谨慎使用或避免使用</strong>，因为数字枚举存在一些不安全的行为。字符串枚举相对更安全。</span></li>
                </ul>
                <h3>类型操作符</h3>
                <ul>
                    <li><span class="hl-term"><strong>类型别名 (Type Alias)</strong></span>: <code>type MyString = string;</code></li>
                    <li><span class="hl-term"><strong>联合类型 (Union Types)</strong></span>: <code>string | number</code> (表示“或”)</li>
                    <li><span class="hl-term"><strong>交叉类型 (Intersection Types)</strong></span>: <code>TypeA & TypeB</code> (表示“与”，合并两个类型的成员)</li>
                </ul>
            </div>
        </details>
        
        <details>
            <summary>第四章：函数</summary>
            <div class="content">
                <h3>函数类型签名</h3>
                <p><span class="hl-fact">函数的参数类型通常需要显式注解，而返回类型 TypeScript 大多可以自动推断。</span></p>
                <pre><code>// 完整的调用签名
type Log = (message: string, userId?: string) => void;</code></pre>
                <h3>重要概念</h3>
                <ul>
                    <li><strong>可选参数和默认参数</strong>: <code>function log(msg: string, user = 'guest') { ... }</code></li>
                    <li><strong>重载 (Overloads)</strong>: <span class="hl-fact">为一个函数提供多个不同的调用签名，以处理不同的参数组合。实现函数本身需要一个能兼容所有重载签名的通用签名。</span></li>
                    <li><strong><code>this</code> 的类型</strong>: <span class="hl-point">为了安全地使用 <code>this</code>，应在函数的第一个参数位置声明它的类型：<code>function say(this: MyType, message: string) { ... }</code>。</span></li>
                    <li><span class="hl-term"><strong>多态 (Polymorphism) / 泛型 (Generics)</strong></span>:
                        <p><span class="hl-fact">这是 TypeScript 最强大的功能之一，用于编写可处理多种类型的、可复用的代码。使用尖括号 <code>&lt;T&gt;</code> 来声明一个泛型类型参数。</span></p>
                        <pre><code>function map&lt;T, U&gt;(array: T[], f: (item: T) => U): U[] {
  // ...
}</code></pre>
                    </li>
                </ul>
            </div>
        </details>

        <details>
            <summary>第五章：类与接口</summary>
            <div class="content">
                <h3>核心特性</h3>
                <ul>
                    <li><strong>类 (Classes)</strong>: <span class="hl-fact">支持访问修饰符 (<code>public</code>, <code>protected</code>, <code>private</code>)、<code>abstract</code> 抽象类、<code>readonly</code> 属性等。</span></li>
                    <li><strong>接口 (Interfaces)</strong>: <span class="hl-fact">仅用于描述类型的“形状”，在编译后会被擦除。</span></li>
                </ul>
                <h4><code>interface</code> vs. <code>type</code></h4>
                <ul>
                    <li><span class="hl-fact"><strong>接口是“开放的”</strong>：同名的多个接口会自动合并（<span class="hl-term">声明合并 Declaration Merging</span>）。这对于扩展第三方库的类型非常有用。</span></li>
                    <li><span class="hl-fact"><strong>类型别名是“封闭的”</strong>：不能重复声明，但更通用，可以表示联合类型、元组等任何类型。</span></li>
                    <li><span class="hl-point">作者建议：当描述一个对象或类的形状时，优先使用 <code>interface</code>；其他情况使用 <code>type</code>。</span></li>
                </ul>
                <h3>高级模式</h3>
                <ul>
                    <li><strong>Mixins</strong>: <span class="hl-fact">通过函数返回类的模式，来模拟多重继承，为类混入多种行为。</span></li>
                    <li><strong>Decorators</strong>: <span class="hl-point">实验性功能，提供一种元编程的语法糖来修改类、方法或属性。</span></li>
                </ul>
            </div>
        </details>
        
        <details>
            <summary>第六章：高级类型</summary>
            <div class="content">
                <h3>类型关系</h3>
                <ul>
                    <li><strong>子类型 (Subtyping)</strong>: <span class="hl-fact">如果类型 <code>B</code> 是 <code>A</code> 的子类型 (<code>B <: A</code>)，那么任何需要 <code>A</code> 的地方都可以安全地使用 <code>B</code>。</span></li>
                    <li><strong>型变 (Variance)</strong>:
                        <ul>
                            <li><span class="hl-term"><strong>协变 (Covariance)</strong></span>: <span class="hl-fact">大多数类型（如对象属性、函数返回值）都是协变的。如果 <code>Cat <: Animal</code>，那么 <code>Cat[] <: Animal[]</code>。</span></li>
                            <li><span class="hl-term"><strong>逆变 (Contravariance)</strong></span>: <span class="hl-fact">函数参数是逆变的。如果 <code>Cat <: Animal</code>，那么 <code>(animal: Animal) => void</code> 是 <code>(cat: Cat) => void</code> 的子类型。</span></li>
                        </ul>
                    </li>
                    <li><strong>类型拓宽 (Type Widening)</strong>: <span class="hl-fact">当使用 <code>let</code> 或 <code>var</code> 声明变量时，TypeScript 会推断一个更通用的类型。而使用 <code>const</code> 声明时，会推断出最窄的字面量类型。可以使用 <code>as const</code> 来强制进行最窄推断。</span></li>
                </ul>
                <h3>高级类型操作</h3>
                <ul>
                    <li><strong>类型收窄 (Type Narrowing / Refinement)</strong>: <span class="hl-fact">通过 <code>if</code>, <code>typeof</code>, <code>instanceof</code> 等控制流分析，TypeScript 可以在代码块内将一个宽泛的类型“收窄”为一个更具体的类型。</span></li>
                    <li><span class="hl-term"><strong>可辨识联合类型 (Discriminated Unions)</strong></span>: <span class="hl-point">一种强大的模式，通过给联合类型中的每个成员添加一个共同的、具有字面量类型的字段（“标签”），可以实现完美的类型收窄和穷尽性检查。</span>
                        <pre><code>type Success = { type: 'success', response: ... };
type Failure = { type: 'failure', error: ... };
type Result = Success | Failure;

function handle(r: Result) {
  if (r.type === 'success') {
    // r 在这里被收窄为 Success 类型
  } else {
    // r 在这里是 Failure 类型
  }
}</code></pre>
                    </li>
                    <li><code>keyof T</code>: <span class="hl-fact">获取类型 <code>T</code> 的所有键，结果是一个联合类型。</span></li>
                    <li><code>T[K]</code> (索引访问类型): <span class="hl-fact">获取类型 <code>T</code> 中键 <code>K</code> 对应的属性类型。</span></li>
                    <li><span class="hl-term"><strong>映射类型 (Mapped Types)</strong></span>: <span class="hl-fact">基于一个已有类型创建新类型，例如 <code>{ [K in keyof T]: T[K] }</code>。<code>Partial&lt;T&gt;</code>, <code>Readonly&lt;T&gt;</code> 等内置工具类型就是用它实现的。</span></li>
                    <li><span class="hl-term"><strong>条件类型 (Conditional Types)</strong></span>: <span class="hl-fact"><code>T extends U ? X : Y</code>。它允许类型根据条件进行选择，并且当 <code>T</code> 是联合类型时，具有<strong>分配特性 (Distributive)</strong>。</span></li>
                    <li><code>infer</code> 关键字: <span class="hl-fact">在条件类型中，可以动态地推断出一个新的类型变量。</span></li>
                </ul>
            </div>
        </details>
        
        <details>
            <summary>第七、八章：错误处理与异步编程</summary>
            <div class="content">
                <h3>错误处理模式</h3>
                <ol>
                    <li><strong>返回 <code>null</code></strong>: <span class="hl-point">简单，但丢失了错误信息。</span></li>
                    <li><strong>抛出异常 (Throwing Exceptions)</strong>: <span class="hl-point">强大，但类型签名中不体现，破坏了类型安全。</span></li>
                    <li><strong>返回异常 (Returning Exceptions)</strong>: <span class="hl-point"><code>function(): Result | Error</code>。类型安全，强制调用者处理错误，但链式调用会变得冗长。</span></li>
                    <li><strong>Option 类型</strong>: <span class="hl-point">函数式编程模式，将结果包装在 <code>Some(value)</code> 或 <code>None</code> 容器中，可以优雅地进行链式调用。</span></li>
                </ol>
                <h3>异步编程</h3>
                <ul>
                    <li><strong>回调函数 (Callbacks)</strong>: <span class="hl-fact">基础，但容易导致“回调地狱”。</span></li>
                    <li><strong>Promises</strong>: <span class="hl-fact">现代 JavaScript 异步标准，通过 <code>.then()</code> 和 <code>.catch()</code> 解决回调地狱，使异步代码更易于组合和管理。</span></li>
                    <li><code>async</code>/<code>await</code>: <span class="hl-fact">Promise 的语法糖，让你可以用同步的方式编写异步代码，极大提高了可读性。</span></li>
                    <li><strong>类型安全的事件发射器</strong>: <span class="hl-point">可以使用映射类型来创建一个协议，精确地为每个事件名称定义其负载类型。</span></li>
                </ul>
            </div>
        </details>

        <details>
            <summary>第九章至十二章：框架、JavaScript 互操作与构建</summary>
            <div class="content">
                <h3>与 JavaScript 互操作</h3>
                <ul>
                    <li><span class="hl-term"><strong>声明文件 (`.d.ts`)</strong></span>: <span class="hl-fact">是 TypeScript 与 JavaScript 库协作的基石。它只包含类型信息，不包含实现。</span></li>
                    <li><strong>DefinitelyTyped</strong>: <span class="hl-fact">一个庞大的社区维护的声明文件仓库。大多数流行的 JS 库都可以通过安装 <code>@types/&lt;package-name&gt;</code> 来获得类型支持。</span></li>
                    <li><strong>渐进式迁移策略</strong>:
                        <ol>
                            <li>在 <code>tsconfig.json</code> 中启用 <code>allowJs: true</code>。</li>
                            <li>（可选）启用 <code>checkJs: true</code> 并使用 <code>// @ts-check</code> 或 JSDoc 注解来为 JS 文件添加类型检查。</li>
                            <li>逐个将 <code>.js</code> 文件重命名为 <code>.ts</code> 或 <code>.tsx</code> 并修复类型错误。</li>
                            <li>最终开启 <code>strict: true</code> 模式，实现完全的类型安全。</li>
                        </ol>
                    </li>
                </ul>
                <h3>模块与构建</h3>
                <ul>
                    <li><strong>模块系统</strong>: <span class="hl-point">始终优先使用 ES 模块 (<code>import</code>/<code>export</code>)。命名空间 (<code>namespace</code>) 是一种较旧的、不推荐的模式。</span></li>
                    <li><strong><code>tsconfig.json</code> 核心配置</strong>:
                        <ul>
                            <li><code>target</code>: <span class="hl-fact">指定编译输出的 JavaScript 版本（如 <code>"es2015"</code>）。</span></li>
                            <li><code>module</code>: <span class="hl-fact">指定输出的模块规范（如 <code>"commonjs"</code> 用于 Node.js，<code>"esnext"</code> 用于现代打包工具）。</span></li>
                            <li><code>lib</code>: <span class="hl-fact">指定项目中可用的运行时库（如 <code>"dom"</code> 用于浏览器环境，<code>"es2020"</code> 用于 JS 新特性）。</span></li>
                        </ul>
                    </li>
                    <li><strong>项目结构</strong>: <span class="hl-point">推荐将源码放在 <code>src/</code> 目录，编译输出到 <code>dist/</code> 目录。</span></li>
                </ul>
            </div>
        </details>
        
    </div>


<div class="attachments-panel" id="attachments-panel">
    <h3>原文</h3>
    <a href="book_boris_programing_typescript_files/book.html" target="_blank">源链接</a>
    <h3>附件</h3>
        <div class="attachment-item">
            <h4>中文PDF <span class="file-size">(文件不存在)</span></h4>
            <a href="book_boris_programing_typescript_files/book.pdf" class="download-btn" download>下载</a>
        </div>
        <div class="attachment-item">
            <h4>中文epub <span class="file-size">(文件不存在)</span></h4>
            <a href="book_boris_programing_typescript_files/book.epub" class="download-btn" download>下载</a>
        </div>
</div>
<button class="float-toggle" id="float-toggle" title="打开附件面板">◁</button>
<script>
// 浮动框展开/收起功能
document.addEventListener('DOMContentLoaded', function() {
    const panel = document.getElementById('attachments-panel');
    const toggleBtn = document.getElementById('float-toggle');
    
    if (!panel || !toggleBtn) return;
    
    // 切换面板显示状态
    function togglePanel() {
        panel.classList.toggle('expanded');
        // 更新按钮图标
        const isExpanded = panel.classList.contains('expanded');
        toggleBtn.textContent = isExpanded ? '▷' : '◁';
        toggleBtn.title = isExpanded ? '关闭附件面板' : '打开附件面板';
        
        // 动态调整按钮位置
        if (isExpanded) {
            // 等待面板展开动画完成后调整按钮位置
            setTimeout(() => {
                const panelWidth = panel.offsetWidth;
                toggleBtn.style.right = (panelWidth + 30) + 'px';
            }, 300);
        } else {
            toggleBtn.style.right = '10px';
        }
    }
    
    // 点击切换按钮
    toggleBtn.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        togglePanel();
    });
    
    // 点击页面其他地方时收起面板
    document.addEventListener('click', function(e) {
        const isClickOnPanel = panel.contains(e.target);
        const isClickOnToggle = toggleBtn.contains(e.target);
        
        if (!isClickOnPanel && !isClickOnToggle) {
            panel.classList.remove('expanded');
            toggleBtn.textContent = '◁';
            toggleBtn.title = '打开附件面板';
            toggleBtn.style.right = '10px'; // 重置按钮位置
        }
    });
    
    // ESC键关闭面板
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && panel.classList.contains('expanded')) {
            panel.classList.remove('expanded');
            toggleBtn.textContent = '◁';
            toggleBtn.title = '打开附件面板';
            toggleBtn.style.right = '10px'; // 重置按钮位置
        }
    });
});
</script>
</body>
</html>